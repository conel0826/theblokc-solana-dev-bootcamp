{"ast":null,"code":"import _toArray from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _createClass from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _wrapNativeSuper from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(toFailures);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inherits(StructError, _TypeError);\n  function StructError(failure, failures) {\n    var _this;\n    _classCallCheck(this, StructError);\n    var cached;\n    var message = failure.message,\n      rest = _objectWithoutProperties(failure, [\"message\"]);\n    var path = failure.path;\n    var msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StructError).call(this, msg));\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), rest);\n    _this.name = _this.constructor.name;\n    _this.failures = function () {\n      var _cached;\n      return (_cached = cached) != null ? _cached : cached = [failure].concat(_toConsumableArray(failures()));\n    };\n    return _this;\n  }\n  return StructError;\n}(_wrapNativeSuper(TypeError));\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n  var prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  var _input$next = input.next(),\n    done = _input$next.done,\n    value = _input$next.value;\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n  var path = context.path,\n    branch = context.branch;\n  var type = struct.type;\n  var _result = result,\n    refinement = _result.refinement,\n    _result$message = _result.message,\n    message = _result$message === void 0 ? \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\" : _result$message;\n  return _objectSpread({\n    value: value,\n    type: type,\n    refinement: refinement,\n    key: path[path.length - 1],\n    path: path,\n    branch: branch\n  }, result, {\n    message: message\n  });\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction toFailures(result, context, struct, value) {\n  var _iterator, _step, r, failure;\n  return _regeneratorRuntime().wrap(function toFailures$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (!isIterable(result)) {\n          result = [result];\n        }\n        _iterator = _createForOfIteratorHelper(result);\n        _context.prev = 2;\n        _iterator.s();\n      case 4:\n        if ((_step = _iterator.n()).done) {\n          _context.next = 12;\n          break;\n        }\n        r = _step.value;\n        failure = toFailure(r, context, struct, value);\n        if (!failure) {\n          _context.next = 10;\n          break;\n        }\n        _context.next = 10;\n        return failure;\n      case 10:\n        _context.next = 4;\n        break;\n      case 12:\n        _context.next = 17;\n        break;\n      case 14:\n        _context.prev = 14;\n        _context.t0 = _context[\"catch\"](2);\n        _iterator.e(_context.t0);\n      case 17:\n        _context.prev = 17;\n        _iterator.f();\n        return _context.finish(17);\n      case 20:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[2, 14, 17, 20]]);\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction run(value, struct) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _options$path, path, _options$branch, branch, _options$coerce, coerce, _options$mask, mask, ctx, key, valid, _iterator2, _step2, _failure, _iterator3, _step3, _step3$value, k, v, s, ts, _iterator5, _step5, t, _iterator4, _step4, failure;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _options$path = options.path, path = _options$path === void 0 ? [] : _options$path, _options$branch = options.branch, branch = _options$branch === void 0 ? [value] : _options$branch, _options$coerce = options.coerce, coerce = _options$coerce === void 0 ? false : _options$coerce, _options$mask = options.mask, mask = _options$mask === void 0 ? false : _options$mask;\n          ctx = {\n            path: path,\n            branch: branch\n          };\n          if (coerce) {\n            value = struct.coercer(value, ctx);\n            if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n              for (key in value) {\n                if (struct.schema[key] === undefined) {\n                  delete value[key];\n                }\n              }\n            }\n          }\n          valid = true;\n          _iterator2 = _createForOfIteratorHelper(struct.validator(value, ctx));\n          _context2.prev = 5;\n          _iterator2.s();\n        case 7:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 14;\n            break;\n          }\n          _failure = _step2.value;\n          valid = false;\n          _context2.next = 12;\n          return [_failure, undefined];\n        case 12:\n          _context2.next = 7;\n          break;\n        case 14:\n          _context2.next = 19;\n          break;\n        case 16:\n          _context2.prev = 16;\n          _context2.t0 = _context2[\"catch\"](5);\n          _iterator2.e(_context2.t0);\n        case 19:\n          _context2.prev = 19;\n          _iterator2.f();\n          return _context2.finish(19);\n        case 22:\n          _iterator3 = _createForOfIteratorHelper(struct.entries(value, ctx));\n          _context2.prev = 23;\n          _iterator3.s();\n        case 25:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 52;\n            break;\n          }\n          _step3$value = _slicedToArray(_step3.value, 3), k = _step3$value[0], v = _step3$value[1], s = _step3$value[2];\n          ts = run(v, s, {\n            path: k === undefined ? path : [].concat(_toConsumableArray(path), [k]),\n            branch: k === undefined ? branch : [].concat(_toConsumableArray(branch), [v]),\n            coerce: coerce,\n            mask: mask\n          });\n          _iterator5 = _createForOfIteratorHelper(ts);\n          _context2.prev = 29;\n          _iterator5.s();\n        case 31:\n          if ((_step5 = _iterator5.n()).done) {\n            _context2.next = 42;\n            break;\n          }\n          t = _step5.value;\n          if (!t[0]) {\n            _context2.next = 39;\n            break;\n          }\n          valid = false;\n          _context2.next = 37;\n          return [t[0], undefined];\n        case 37:\n          _context2.next = 40;\n          break;\n        case 39:\n          if (coerce) {\n            v = t[1];\n            if (k === undefined) {\n              value = v;\n            } else if (value instanceof Map) {\n              value.set(k, v);\n            } else if (value instanceof Set) {\n              value.add(v);\n            } else if (isObject(value)) {\n              value[k] = v;\n            }\n          }\n        case 40:\n          _context2.next = 31;\n          break;\n        case 42:\n          _context2.next = 47;\n          break;\n        case 44:\n          _context2.prev = 44;\n          _context2.t1 = _context2[\"catch\"](29);\n          _iterator5.e(_context2.t1);\n        case 47:\n          _context2.prev = 47;\n          _iterator5.f();\n          return _context2.finish(47);\n        case 50:\n          _context2.next = 25;\n          break;\n        case 52:\n          _context2.next = 57;\n          break;\n        case 54:\n          _context2.prev = 54;\n          _context2.t2 = _context2[\"catch\"](23);\n          _iterator3.e(_context2.t2);\n        case 57:\n          _context2.prev = 57;\n          _iterator3.f();\n          return _context2.finish(57);\n        case 60:\n          if (!valid) {\n            _context2.next = 79;\n            break;\n          }\n          _iterator4 = _createForOfIteratorHelper(struct.refiner(value, ctx));\n          _context2.prev = 62;\n          _iterator4.s();\n        case 64:\n          if ((_step4 = _iterator4.n()).done) {\n            _context2.next = 71;\n            break;\n          }\n          failure = _step4.value;\n          valid = false;\n          _context2.next = 69;\n          return [failure, undefined];\n        case 69:\n          _context2.next = 64;\n          break;\n        case 71:\n          _context2.next = 76;\n          break;\n        case 73:\n          _context2.prev = 73;\n          _context2.t3 = _context2[\"catch\"](62);\n          _iterator4.e(_context2.t3);\n        case 76:\n          _context2.prev = 76;\n          _iterator4.f();\n          return _context2.finish(76);\n        case 79:\n          if (!valid) {\n            _context2.next = 82;\n            break;\n          }\n          _context2.next = 82;\n          return [undefined, value];\n        case 82:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[5, 16, 19, 22], [23, 54, 57, 60], [29, 44, 47, 50], [62, 73, 76, 79]]);\n  })();\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nvar Struct = /*#__PURE__*/function () {\n  function Struct(props) {\n    var _this2 = this;\n    _classCallCheck(this, Struct);\n    var type = props.type,\n      schema = props.schema,\n      validator = props.validator,\n      refiner = props.refiner,\n      _props$coercer = props.coercer,\n      coercer = _props$coercer === void 0 ? function (value) {\n        return value;\n      } : _props$coercer,\n      _props$entries = props.entries,\n      entries = _props$entries === void 0 ? /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee2);\n      }) : _props$entries;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = function (value, context) {\n        var result = validator(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.validator = function () {\n        return [];\n      };\n    }\n    if (refiner) {\n      this.refiner = function (value, context) {\n        var result = refiner(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.refiner = function () {\n        return [];\n      };\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  _createClass(Struct, [{\n    key: \"assert\",\n    value: function assert(value) {\n      return _assert(value, this);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n  }, {\n    key: \"create\",\n    value: function create(value) {\n      return _create(value, this);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n  }, {\n    key: \"is\",\n    value: function is(value) {\n      return _is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n  }, {\n    key: \"mask\",\n    value: function mask(value) {\n      return _mask(value, this);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _validate(value, this, options);\n    }\n  }]);\n  return Struct;\n}();\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction _assert(value, struct) {\n  var result = _validate(value, struct);\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction _create(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction _mask(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction _is(value, struct) {\n  var result = _validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction _validate(value, struct) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var tuples = run(value, struct, options);\n  var tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    var error = new StructError(tuple[0], /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var _iterator6, _step6, t;\n      return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _iterator6 = _createForOfIteratorHelper(tuples);\n            _context4.prev = 1;\n            _iterator6.s();\n          case 3:\n            if ((_step6 = _iterator6.n()).done) {\n              _context4.next = 10;\n              break;\n            }\n            t = _step6.value;\n            if (!t[0]) {\n              _context4.next = 8;\n              break;\n            }\n            _context4.next = 8;\n            return t[0];\n          case 8:\n            _context4.next = 3;\n            break;\n          case 10:\n            _context4.next = 15;\n            break;\n          case 12:\n            _context4.prev = 12;\n            _context4.t0 = _context4[\"catch\"](1);\n            _iterator6.e(_context4.t0);\n          case 15:\n            _context4.prev = 15;\n            _iterator6.f();\n            return _context4.finish(15);\n          case 18:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee3, null, [[1, 12, 15, 18]]);\n    }));\n    return [error, undefined];\n  } else {\n    var v = tuple[1];\n    return [undefined, v];\n  }\n}\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n  var schemas = Structs.map(function (s) {\n    return s.schema;\n  });\n  var schema = Object.assign.apply(Object, [{}].concat(_toConsumableArray(schemas)));\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator: validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nfunction deprecated(struct, log) {\n  return new Struct(_objectSpread({}, struct, {\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    },\n    validator: function validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n  }));\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value, ctx) {\n      var struct;\n      return _regeneratorRuntime().wrap(function entries$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            struct = fn(value, ctx);\n            return _context5.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n          case 2:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nfunction lazy(fn) {\n  var struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value, ctx) {\n      var _struct;\n      return _regeneratorRuntime().wrap(function entries$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            (_struct = struct) != null ? _struct : struct = fn();\n            return _context6.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n          case 2:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var _struct2;\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var _struct3;\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nfunction omit(struct, keys) {\n  var schema = struct.schema;\n  var subschema = _objectSpread({}, schema);\n  var _iterator7 = _createForOfIteratorHelper(keys),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var key = _step7.value;\n      delete subschema[key];\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nfunction partial(struct) {\n  var schema = struct instanceof Struct ? _objectSpread({}, struct.schema) : _objectSpread({}, struct);\n  for (var key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nfunction pick(struct, keys) {\n  var schema = struct.schema;\n  var subschema = {};\n  var _iterator8 = _createForOfIteratorHelper(keys),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var key = _step8.value;\n      subschema[key] = schema[key];\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', function () {\n    return true;\n  });\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _iterator9, _step9, _step9$value, i, v;\n      return _regeneratorRuntime().wrap(function entries$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!(Element && Array.isArray(value))) {\n              _context7.next = 18;\n              break;\n            }\n            _iterator9 = _createForOfIteratorHelper(value.entries());\n            _context7.prev = 2;\n            _iterator9.s();\n          case 4:\n            if ((_step9 = _iterator9.n()).done) {\n              _context7.next = 10;\n              break;\n            }\n            _step9$value = _slicedToArray(_step9.value, 2), i = _step9$value[0], v = _step9$value[1];\n            _context7.next = 8;\n            return [i, v, Element];\n          case 8:\n            _context7.next = 4;\n            break;\n          case 10:\n            _context7.next = 15;\n            break;\n          case 12:\n            _context7.prev = 12;\n            _context7.t0 = _context7[\"catch\"](2);\n            _iterator9.e(_context7.t0);\n          case 15:\n            _context7.prev = 15;\n            _iterator9.f();\n            return _context7.finish(15);\n          case 18:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', function (value) {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return define('date', function (value) {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\nfunction enums(values) {\n  var schema = {};\n  var description = values.map(function (v) {\n    return print(v);\n  }).join();\n  var _iterator10 = _createForOfIteratorHelper(values),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var key = _step10.value;\n      schema[key] = key;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return new Struct({\n    type: 'enums',\n    schema: schema,\n    validator: function validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\nfunction func() {\n  return define('func', function (value) {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nfunction instance(Class) {\n  return define('instance', function (value) {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\nfunction integer() {\n  return define('integer', function (value) {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value, ctx) {\n      var _iterator11, _step11, S;\n      return _regeneratorRuntime().wrap(function entries$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _iterator11 = _createForOfIteratorHelper(Structs);\n            _context8.prev = 1;\n            _iterator11.s();\n          case 3:\n            if ((_step11 = _iterator11.n()).done) {\n              _context8.next = 8;\n              break;\n            }\n            S = _step11.value;\n            return _context8.delegateYield(S.entries(value, ctx), \"t0\", 6);\n          case 6:\n            _context8.next = 3;\n            break;\n          case 8:\n            _context8.next = 13;\n            break;\n          case 10:\n            _context8.prev = 10;\n            _context8.t1 = _context8[\"catch\"](1);\n            _iterator11.e(_context8.t1);\n          case 13:\n            _context8.prev = 13;\n            _iterator11.f();\n            return _context8.finish(13);\n          case 16:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, entries, null, [[1, 10, 13, 16]]);\n    }),\n    validator: /*#__PURE__*/_regeneratorRuntime().mark(function validator(value, ctx) {\n      var _iterator12, _step12, S;\n      return _regeneratorRuntime().wrap(function validator$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            _iterator12 = _createForOfIteratorHelper(Structs);\n            _context9.prev = 1;\n            _iterator12.s();\n          case 3:\n            if ((_step12 = _iterator12.n()).done) {\n              _context9.next = 8;\n              break;\n            }\n            S = _step12.value;\n            return _context9.delegateYield(S.validator(value, ctx), \"t0\", 6);\n          case 6:\n            _context9.next = 3;\n            break;\n          case 8:\n            _context9.next = 13;\n            break;\n          case 10:\n            _context9.prev = 10;\n            _context9.t1 = _context9[\"catch\"](1);\n            _iterator12.e(_context9.t1);\n          case 13:\n            _context9.prev = 13;\n            _iterator12.f();\n            return _context9.finish(13);\n          case 16:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, validator, null, [[1, 10, 13, 16]]);\n    }),\n    refiner: /*#__PURE__*/_regeneratorRuntime().mark(function refiner(value, ctx) {\n      var _iterator13, _step13, S;\n      return _regeneratorRuntime().wrap(function refiner$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            _iterator13 = _createForOfIteratorHelper(Structs);\n            _context10.prev = 1;\n            _iterator13.s();\n          case 3:\n            if ((_step13 = _iterator13.n()).done) {\n              _context10.next = 8;\n              break;\n            }\n            S = _step13.value;\n            return _context10.delegateYield(S.refiner(value, ctx), \"t0\", 6);\n          case 6:\n            _context10.next = 3;\n            break;\n          case 8:\n            _context10.next = 13;\n            break;\n          case 10:\n            _context10.prev = 10;\n            _context10.t1 = _context10[\"catch\"](1);\n            _iterator13.e(_context10.t1);\n          case 13:\n            _context10.prev = 13;\n            _iterator13.f();\n            return _context10.finish(13);\n          case 16:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, refiner, null, [[1, 10, 13, 16]]);\n    })\n  });\n}\nfunction literal(constant) {\n  var description = print(constant);\n  var t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator: function validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _iterator14, _step14, _step14$value, k, v;\n      return _regeneratorRuntime().wrap(function entries$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            if (!(Key && Value && value instanceof Map)) {\n              _context11.next = 20;\n              break;\n            }\n            _iterator14 = _createForOfIteratorHelper(value.entries());\n            _context11.prev = 2;\n            _iterator14.s();\n          case 4:\n            if ((_step14 = _iterator14.n()).done) {\n              _context11.next = 12;\n              break;\n            }\n            _step14$value = _slicedToArray(_step14.value, 2), k = _step14$value[0], v = _step14$value[1];\n            _context11.next = 8;\n            return [k, k, Key];\n          case 8:\n            _context11.next = 10;\n            return [k, v, Value];\n          case 10:\n            _context11.next = 4;\n            break;\n          case 12:\n            _context11.next = 17;\n            break;\n          case 14:\n            _context11.prev = 14;\n            _context11.t0 = _context11[\"catch\"](2);\n            _iterator14.e(_context11.t0);\n          case 17:\n            _context11.prev = 17;\n            _iterator14.f();\n            return _context11.finish(17);\n          case 20:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, entries, null, [[2, 14, 17, 20]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\nfunction never() {\n  return define('never', function () {\n    return false;\n  });\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct(_objectSpread({}, struct, {\n    validator: function validator(value, ctx) {\n      return value === null || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === null || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', function (value) {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\nfunction object(schema) {\n  var knowns = schema ? Object.keys(schema) : [];\n  var Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var unknowns, _iterator15, _step15, key, _iterator16, _step16, _key2;\n      return _regeneratorRuntime().wrap(function entries$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            if (!(schema && isObject(value))) {\n              _context12.next = 37;\n              break;\n            }\n            unknowns = new Set(Object.keys(value));\n            _iterator15 = _createForOfIteratorHelper(knowns);\n            _context12.prev = 3;\n            _iterator15.s();\n          case 5:\n            if ((_step15 = _iterator15.n()).done) {\n              _context12.next = 12;\n              break;\n            }\n            key = _step15.value;\n            unknowns.delete(key);\n            _context12.next = 10;\n            return [key, value[key], schema[key]];\n          case 10:\n            _context12.next = 5;\n            break;\n          case 12:\n            _context12.next = 17;\n            break;\n          case 14:\n            _context12.prev = 14;\n            _context12.t0 = _context12[\"catch\"](3);\n            _iterator15.e(_context12.t0);\n          case 17:\n            _context12.prev = 17;\n            _iterator15.f();\n            return _context12.finish(17);\n          case 20:\n            _iterator16 = _createForOfIteratorHelper(unknowns);\n            _context12.prev = 21;\n            _iterator16.s();\n          case 23:\n            if ((_step16 = _iterator16.n()).done) {\n              _context12.next = 29;\n              break;\n            }\n            _key2 = _step16.value;\n            _context12.next = 27;\n            return [_key2, value[_key2], Never];\n          case 27:\n            _context12.next = 23;\n            break;\n          case 29:\n            _context12.next = 34;\n            break;\n          case 31:\n            _context12.prev = 31;\n            _context12.t1 = _context12[\"catch\"](21);\n            _iterator16.e(_context12.t1);\n          case 34:\n            _context12.prev = 34;\n            _iterator16.f();\n            return _context12.finish(34);\n          case 37:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, entries, null, [[3, 14, 17, 20], [21, 31, 34, 37]]);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n    coercer: function coercer(value) {\n      return isObject(value) ? _objectSpread({}, value) : value;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct(_objectSpread({}, struct, {\n    validator: function validator(value, ctx) {\n      return value === undefined || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var k, v;\n      return _regeneratorRuntime().wrap(function entries$(_context13) {\n        while (1) switch (_context13.prev = _context13.next) {\n          case 0:\n            if (!isObject(value)) {\n              _context13.next = 11;\n              break;\n            }\n            _context13.t0 = _regeneratorRuntime().keys(value);\n          case 2:\n            if ((_context13.t1 = _context13.t0()).done) {\n              _context13.next = 11;\n              break;\n            }\n            k = _context13.t1.value;\n            v = value[k];\n            _context13.next = 7;\n            return [k, k, Key];\n          case 7:\n            _context13.next = 9;\n            return [k, v, Value];\n          case 9:\n            _context13.next = 2;\n            break;\n          case 11:\n          case \"end\":\n            return _context13.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nfunction regexp() {\n  return define('regexp', function (value) {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _iterator17, _step17, v;\n      return _regeneratorRuntime().wrap(function entries$(_context14) {\n        while (1) switch (_context14.prev = _context14.next) {\n          case 0:\n            if (!(Element && value instanceof Set)) {\n              _context14.next = 18;\n              break;\n            }\n            _iterator17 = _createForOfIteratorHelper(value);\n            _context14.prev = 2;\n            _iterator17.s();\n          case 4:\n            if ((_step17 = _iterator17.n()).done) {\n              _context14.next = 10;\n              break;\n            }\n            v = _step17.value;\n            _context14.next = 8;\n            return [v, v, Element];\n          case 8:\n            _context14.next = 4;\n            break;\n          case 10:\n            _context14.next = 15;\n            break;\n          case 12:\n            _context14.prev = 12;\n            _context14.t0 = _context14[\"catch\"](2);\n            _iterator17.e(_context14.t0);\n          case 15:\n            _context14.prev = 15;\n            _iterator17.f();\n            return _context14.finish(15);\n          case 18:\n          case \"end\":\n            return _context14.stop();\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', function (value) {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\nfunction tuple(Elements) {\n  var Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var length, i;\n      return _regeneratorRuntime().wrap(function entries$(_context15) {\n        while (1) switch (_context15.prev = _context15.next) {\n          case 0:\n            if (!Array.isArray(value)) {\n              _context15.next = 9;\n              break;\n            }\n            length = Math.max(Elements.length, value.length);\n            i = 0;\n          case 3:\n            if (!(i < length)) {\n              _context15.next = 9;\n              break;\n            }\n            _context15.next = 6;\n            return [i, value[i], Elements[i] || Never];\n          case 6:\n            i++;\n            _context15.next = 3;\n            break;\n          case 9:\n          case \"end\":\n            return _context15.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  var keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema: schema,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _i, _keys, k;\n      return _regeneratorRuntime().wrap(function entries$(_context16) {\n        while (1) switch (_context16.prev = _context16.next) {\n          case 0:\n            if (!isObject(value)) {\n              _context16.next = 9;\n              break;\n            }\n            _i = 0, _keys = keys;\n          case 2:\n            if (!(_i < _keys.length)) {\n              _context16.next = 9;\n              break;\n            }\n            k = _keys[_i];\n            _context16.next = 6;\n            return [k, value[k], schema[k]];\n          case 6:\n            _i++;\n            _context16.next = 2;\n            break;\n          case 9:\n          case \"end\":\n            return _context16.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\nfunction union(Structs) {\n  var description = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    validator: function validator(value, ctx) {\n      var failures = [];\n      var _iterator18 = _createForOfIteratorHelper(Structs),\n        _step18;\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var S = _step18.value;\n          var _run = run(value, S, ctx),\n            _run2 = _toArray(_run),\n            tuples = _run2.slice(0);\n          var _tuples = _slicedToArray(tuples, 1),\n            first = _tuples[0];\n          if (!first[0]) {\n            return [];\n          } else {\n            var _iterator19 = _createForOfIteratorHelper(tuples),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _step19$value = _slicedToArray(_step19.value, 1),\n                  failure = _step19$value[0];\n                if (failure) {\n                  failures.push(failure);\n                }\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value)].concat(failures);\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', function () {\n    return true;\n  });\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, _coercer) {\n  return new Struct(_objectSpread({}, struct, {\n    coercer: function coercer(value, ctx) {\n      return _is(value, condition) ? struct.coercer(_coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  }));\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction defaulted(struct, fallback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return coerce(struct, unknown(), function (x) {\n    var f = typeof fallback === 'function' ? fallback() : fallback;\n    if (x === undefined) {\n      return f;\n    }\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      var ret = _objectSpread({}, x);\n      var changed = false;\n      for (var key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n      if (changed) {\n        return ret;\n      }\n    }\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), function (x) {\n    return x.trim();\n  });\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nfunction empty(struct) {\n  var expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', function (value) {\n    if (value instanceof Map || value instanceof Set) {\n      var _size = value.size;\n      return _size === 0 || expected + \" but received one with a size of `\" + _size + \"`\";\n    } else {\n      var length = value.length;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nfunction max(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'max', function (value) {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nfunction min(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'min', function (value) {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', function (value) {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nfunction size(struct, min) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;\n  var expected = \"Expected a \" + struct.type;\n  var of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', function (value) {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      var _size2 = value.size;\n      return min <= _size2 && _size2 <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + _size2 + \"`\";\n    } else {\n      var length = value.length;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nfunction refine(struct, name, refiner) {\n  return new Struct(_objectSpread({}, struct, {\n    refiner: function (_refiner) {\n      var _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(refiner);\n      function refiner(_x, _x2) {\n        var _args17 = arguments;\n        return _regeneratorRuntime().wrap(function refiner$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              return _context17.delegateYield(_refiner.apply(this, _args17), \"t0\", 1);\n            case 1:\n              return _context17.abrupt(\"return\", _context17.t0);\n            case 2:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _marked2, this);\n      }\n      refiner.toString = function () {\n        return _refiner.toString();\n      };\n      return refiner;\n    }( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(value, ctx) {\n      var result, failures, _iterator20, _step20, failure;\n      return _regeneratorRuntime().wrap(function _callee4$(_context18) {\n        while (1) switch (_context18.prev = _context18.next) {\n          case 0:\n            return _context18.delegateYield(struct.refiner(value, ctx), \"t0\", 1);\n          case 1:\n            result = refiner(value, ctx);\n            failures = toFailures(result, ctx, struct, value);\n            _iterator20 = _createForOfIteratorHelper(failures);\n            _context18.prev = 4;\n            _iterator20.s();\n          case 6:\n            if ((_step20 = _iterator20.n()).done) {\n              _context18.next = 12;\n              break;\n            }\n            failure = _step20.value;\n            _context18.next = 10;\n            return _objectSpread({}, failure, {\n              refinement: name\n            });\n          case 10:\n            _context18.next = 6;\n            break;\n          case 12:\n            _context18.next = 17;\n            break;\n          case 14:\n            _context18.prev = 14;\n            _context18.t1 = _context18[\"catch\"](4);\n            _iterator20.e(_context18.t1);\n          case 17:\n            _context18.prev = 17;\n            _iterator20.f();\n            return _context18.finish(17);\n          case 20:\n          case \"end\":\n            return _context18.stop();\n        }\n      }, _callee4, null, [[4, 14, 17, 20]]);\n    }))\n  }));\n}\nexport { Struct, StructError, any, array, _assert as assert, assign, boolean, coerce, _create as create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, _is as is, lazy, literal, map, _mask as mask, max, min, never, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, _validate as validate };","map":null,"metadata":{},"sourceType":"module"}