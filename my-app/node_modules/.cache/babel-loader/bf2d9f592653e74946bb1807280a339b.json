{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.montgomery = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar modular_js_1 = require(\"./modular.js\");\nvar utils_js_1 = require(\"./utils.js\");\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\nfunction validateOpts(curve) {\n  (0, utils_js_1.validateObject)(curve, {\n    a: 'bigint'\n  }, {\n    montgomeryBits: 'isSafeInteger',\n    nByteLength: 'isSafeInteger',\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    powPminus2: 'function',\n    Gu: 'bigint'\n  });\n  // Set defaults\n  return Object.freeze(_objectSpread({}, curve));\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n  var CURVE = validateOpts(curveDef);\n  var P = CURVE.P;\n  var modP = function modP(n) {\n    return (0, modular_js_1.mod)(n, P);\n  };\n  var montgomeryBits = CURVE.montgomeryBits;\n  var montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  var fieldLen = CURVE.nByteLength;\n  var adjustScalarBytes = CURVE.adjustScalarBytes || function (bytes) {\n    return bytes;\n  };\n  var powPminus2 = CURVE.powPminus2 || function (x) {\n    return (0, modular_js_1.pow)(x, P - BigInt(2), P);\n  };\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap, x_2, x_3) {\n    var dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n  // Accepts 0 as well\n  function assertFieldElement(n) {\n    if (typeof n === 'bigint' && _0n <= n && n < P) return n;\n    throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n  }\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  var a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(pointU, scalar) {\n    var u = assertFieldElement(pointU);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    var k = assertFieldElement(scalar);\n    var x_1 = u;\n    var x_2 = _1n;\n    var z_2 = _0n;\n    var x_3 = u;\n    var z_3 = _1n;\n    var swap = _0n;\n    var sw;\n    for (var t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      var k_t = k >> t & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n      var A = x_2 + z_2;\n      var AA = modP(A * A);\n      var B = x_2 - z_2;\n      var BB = modP(B * B);\n      var E = AA - BB;\n      var C = x_3 + z_3;\n      var D = x_3 - z_3;\n      var DA = modP(D * A);\n      var CB = modP(C * B);\n      var dacb = DA + CB;\n      var da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    var z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n  function encodeUCoordinate(u) {\n    return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);\n  }\n  function decodeUCoordinate(uEnc) {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    // This is very ugly way, but it works because fieldLen-1 is outside of bounds for X448, so this becomes NOOP\n    // fieldLen - scalaryBytes = 1 for X448 and = 0 for X25519\n    var u = (0, utils_js_1.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n    // u[fieldLen-1] crashes QuickJS (TypeError: out-of-bound numeric index)\n    if (fieldLen === montgomeryBytes) u[fieldLen - 1] &= 127; // 0b0111_1111\n    return (0, utils_js_1.bytesToNumberLE)(u);\n  }\n  function decodeScalar(n) {\n    var bytes = (0, utils_js_1.ensureBytes)('scalar', n);\n    if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen) throw new Error(\"Expected \".concat(montgomeryBytes, \" or \").concat(fieldLen, \" bytes, got \").concat(bytes.length));\n    return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar, u) {\n    var pointU = decodeUCoordinate(u);\n    var _scalar = decodeScalar(scalar);\n    var pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  var GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar) {\n    return scalarMult(scalar, GuBytes);\n  }\n  return {\n    scalarMult: scalarMult,\n    scalarMultBase: scalarMultBase,\n    getSharedSecret: function getSharedSecret(privateKey, publicKey) {\n      return scalarMult(privateKey, publicKey);\n    },\n    getPublicKey: function getPublicKey(privateKey) {\n      return scalarMultBase(privateKey);\n    },\n    utils: {\n      randomPrivateKey: function randomPrivateKey() {\n        return CURVE.randomBytes(CURVE.nByteLength);\n      }\n    },\n    GuBytes: GuBytes\n  };\n}\nexports.montgomery = montgomery;","map":null,"metadata":{},"sourceType":"script"}