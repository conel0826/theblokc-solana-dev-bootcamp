{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _objectSpread = require(\"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.twistedEdwards = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\nvar modular_js_1 = require(\"./modular.js\");\nvar ut = require(\"./utils.js\");\nvar utils_js_1 = require(\"./utils.js\");\nvar curve_js_1 = require(\"./curve.js\");\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nvar _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nvar VERIFY_DEFAULT = {\n  zip215: true\n};\nfunction validateOpts(curve) {\n  var opts = (0, curve_js_1.validateBasic)(curve);\n  ut.validateObject(curve, {\n    hash: 'function',\n    a: 'bigint',\n    d: 'bigint',\n    randomBytes: 'function'\n  }, {\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    uvRatio: 'function',\n    mapToCurve: 'function'\n  });\n  // Set defaults\n  return Object.freeze(_objectSpread({}, opts));\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n  var CURVE = validateOpts(curveDef);\n  var Fp = CURVE.Fp,\n    CURVE_ORDER = CURVE.n,\n    prehash = CURVE.prehash,\n    cHash = CURVE.hash,\n    randomBytes = CURVE.randomBytes,\n    nByteLength = CURVE.nByteLength,\n    cofactor = CURVE.h;\n  var MASK = _2n << BigInt(nByteLength * 8) - _1n;\n  var modP = Fp.create; // Function overrides\n  // sqrt(u/v)\n  var uvRatio = CURVE.uvRatio || function (u, v) {\n    try {\n      return {\n        isValid: true,\n        value: Fp.sqrt(u * Fp.inv(v))\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        value: _0n\n      };\n    }\n  };\n  var adjustScalarBytes = CURVE.adjustScalarBytes || function (bytes) {\n    return bytes;\n  }; // NOOP\n  var domain = CURVE.domain || function (data, ctx, phflag) {\n    if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n    return data;\n  }; // NOOP\n  var inBig = function inBig(n) {\n    return typeof n === 'bigint' && _0n < n;\n  }; // n in [1..]\n  var inRange = function inRange(n, max) {\n    return inBig(n) && inBig(max) && n < max;\n  }; // n in [1..max-1]\n  var in0MaskRange = function in0MaskRange(n) {\n    return n === _0n || inRange(n, MASK);\n  }; // n in [0..MASK-1]\n  function assertInRange(n, max) {\n    // n in [1..max-1]\n    if (inRange(n, max)) return n;\n    throw new Error(\"Expected valid scalar < \".concat(max, \", got \").concat(typeof n, \" \").concat(n));\n  }\n  function assertGE0(n) {\n    // n in [0..CURVE_ORDER-1]\n    return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n  }\n\n  var pointPrecomputes = new Map();\n  function isPoint(other) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  var Point = /*#__PURE__*/function () {\n    function Point(ex, ey, ez, et) {\n      _classCallCheck(this, Point);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      if (!in0MaskRange(ex)) throw new Error('x required');\n      if (!in0MaskRange(ey)) throw new Error('y required');\n      if (!in0MaskRange(ez)) throw new Error('z required');\n      if (!in0MaskRange(et)) throw new Error('t required');\n    }\n    _createClass(Point, [{\n      key: \"_setWindowSize\",\n      // \"Private method\", don't use it directly\n      value: function _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n      } // Not required for fromHex(), which always creates valid points.\n      // Could be useful for fromAffine().\n    }, {\n      key: \"assertValidity\",\n      value: function assertValidity() {\n        var a = CURVE.a,\n          d = CURVE.d;\n        if (this.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        var X = this.ex,\n          Y = this.ey,\n          Z = this.ez,\n          T = this.et;\n        var X2 = modP(X * X); // X²\n        var Y2 = modP(Y * Y); // Y²\n        var Z2 = modP(Z * Z); // Z²\n        var Z4 = modP(Z2 * Z2); // Z⁴\n        var aX2 = modP(X2 * a); // aX²\n        var left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        var right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right) throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        var XY = modP(X * Y);\n        var ZT = modP(Z * T);\n        if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n      } // Compare one point to another.\n    }, {\n      key: \"equals\",\n      value: function equals(other) {\n        isPoint(other);\n        var X1 = this.ex,\n          Y1 = this.ey,\n          Z1 = this.ez;\n        var X2 = other.ex,\n          Y2 = other.ey,\n          Z2 = other.ez;\n        var X1Z2 = modP(X1 * Z2);\n        var X2Z1 = modP(X2 * Z1);\n        var Y1Z2 = modP(Y1 * Z2);\n        var Y2Z1 = modP(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n      }\n    }, {\n      key: \"is0\",\n      value: function is0() {\n        return this.equals(Point.ZERO);\n      }\n    }, {\n      key: \"negate\",\n      value: function negate() {\n        // Flips point sign to a negative one (-x, y in affine coords)\n        return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n      } // Fast algo for doubling Extended Point.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n      // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    }, {\n      key: \"double\",\n      value: function double() {\n        var a = CURVE.a;\n        var X1 = this.ex,\n          Y1 = this.ey,\n          Z1 = this.ez;\n        var A = modP(X1 * X1); // A = X12\n        var B = modP(Y1 * Y1); // B = Y12\n        var C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n        var D = modP(a * A); // D = a*A\n        var x1y1 = X1 + Y1;\n        var E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n        var G = D + B; // G = D+B\n        var F = G - C; // F = G-C\n        var H = D - B; // H = D-B\n        var X3 = modP(E * F); // X3 = E*F\n        var Y3 = modP(G * H); // Y3 = G*H\n        var T3 = modP(E * H); // T3 = E*H\n        var Z3 = modP(F * G); // Z3 = F*G\n        return new Point(X3, Y3, Z3, T3);\n      } // Fast algo for adding 2 Extended Points.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n      // Cost: 9M + 1*a + 1*d + 7add.\n    }, {\n      key: \"add\",\n      value: function add(other) {\n        isPoint(other);\n        var a = CURVE.a,\n          d = CURVE.d;\n        var X1 = this.ex,\n          Y1 = this.ey,\n          Z1 = this.ez,\n          T1 = this.et;\n        var X2 = other.ex,\n          Y2 = other.ey,\n          Z2 = other.ez,\n          T2 = other.et; // Faster algo for adding 2 Extended Points when curve's a=-1.\n        // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n        // Cost: 8M + 8add + 2*2.\n        // Note: It does not check whether the `other` point is valid.\n        if (a === BigInt(-1)) {\n          var _A = modP((Y1 - X1) * (Y2 + X2));\n          var _B = modP((Y1 + X1) * (Y2 - X2));\n          var _F = modP(_B - _A);\n          if (_F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n          var _C = modP(Z1 * _2n * T2);\n          var _D = modP(T1 * _2n * Z2);\n          var _E = _D + _C;\n          var _G = _B + _A;\n          var _H = _D - _C;\n          var _X = modP(_E * _F);\n          var _Y = modP(_G * _H);\n          var _T = modP(_E * _H);\n          var _Z = modP(_F * _G);\n          return new Point(_X, _Y, _Z, _T);\n        }\n        var A = modP(X1 * X2); // A = X1*X2\n        var B = modP(Y1 * Y2); // B = Y1*Y2\n        var C = modP(T1 * d * T2); // C = T1*d*T2\n        var D = modP(Z1 * Z2); // D = Z1*Z2\n        var E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n        var F = D - C; // F = D-C\n        var G = D + C; // G = D+C\n        var H = modP(B - a * A); // H = B-a*A\n        var X3 = modP(E * F); // X3 = E*F\n        var Y3 = modP(G * H); // Y3 = G*H\n        var T3 = modP(E * H); // T3 = E*H\n        var Z3 = modP(F * G); // Z3 = F*G\n        return new Point(X3, Y3, Z3, T3);\n      }\n    }, {\n      key: \"subtract\",\n      value: function subtract(other) {\n        return this.add(other.negate());\n      }\n    }, {\n      key: \"wNAF\",\n      value: function wNAF(n) {\n        return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n      } // Constant-time multiplication.\n    }, {\n      key: \"multiply\",\n      value: function multiply(scalar) {\n        var _this$wNAF = this.wNAF(assertInRange(scalar, CURVE_ORDER)),\n          p = _this$wNAF.p,\n          f = _this$wNAF.f;\n        return Point.normalizeZ([p, f])[0];\n      } // Non-constant-time multiplication. Uses double-and-add algorithm.\n      // It's faster, but should only be used when you don't care about\n      // an exposed private key e.g. sig verification.\n      // Does NOT allow scalars higher than CURVE.n.\n    }, {\n      key: \"multiplyUnsafe\",\n      value: function multiplyUnsafe(scalar) {\n        var n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n        if (n === _0n) return I;\n        if (this.equals(I) || n === _1n) return this;\n        if (this.equals(G)) return this.wNAF(n).p;\n        return wnaf.unsafeLadder(this, n);\n      } // Checks if point is of small order.\n      // If you add something to small order point, you will have \"dirty\"\n      // point with torsion component.\n      // Multiplies point by cofactor and checks if the result is 0.\n    }, {\n      key: \"isSmallOrder\",\n      value: function isSmallOrder() {\n        return this.multiplyUnsafe(cofactor).is0();\n      } // Multiplies point by curve order and checks if the result is 0.\n      // Returns `false` is the point is dirty.\n    }, {\n      key: \"isTorsionFree\",\n      value: function isTorsionFree() {\n        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n      } // Converts Extended point to default (x, y) coordinates.\n      // Can accept precomputed Z^-1 - for example, from invertBatch.\n    }, {\n      key: \"toAffine\",\n      value: function toAffine(iz) {\n        var x = this.ex,\n          y = this.ey,\n          z = this.ez;\n        var is0 = this.is0();\n        if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        var ax = modP(x * iz);\n        var ay = modP(y * iz);\n        var zz = modP(z * iz);\n        if (is0) return {\n          x: _0n,\n          y: _1n\n        };\n        if (zz !== _1n) throw new Error('invZ was invalid');\n        return {\n          x: ax,\n          y: ay\n        };\n      }\n    }, {\n      key: \"clearCofactor\",\n      value: function clearCofactor() {\n        var cofactor = CURVE.h;\n        if (cofactor === _1n) return this;\n        return this.multiplyUnsafe(cofactor);\n      } // Converts hash string or Uint8Array to Point.\n      // Uses algo from RFC8032 5.1.3.\n    }, {\n      key: \"toRawBytes\",\n      value: function toRawBytes() {\n        var _this$toAffine = this.toAffine(),\n          x = _this$toAffine.x,\n          y = _this$toAffine.y;\n        var bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n        bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n        return bytes; // and use the last byte to encode sign of x\n      }\n    }, {\n      key: \"toHex\",\n      value: function toHex() {\n        return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n      }\n    }, {\n      key: \"x\",\n      get: function get() {\n        return this.toAffine().x;\n      }\n    }, {\n      key: \"y\",\n      get: function get() {\n        return this.toAffine().y;\n      }\n    }], [{\n      key: \"fromAffine\",\n      value: function fromAffine(p) {\n        if (p instanceof Point) throw new Error('extended point not allowed');\n        var _ref = p || {},\n          x = _ref.x,\n          y = _ref.y;\n        if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error('invalid affine point');\n        return new Point(x, y, _1n, modP(x * y));\n      }\n    }, {\n      key: \"normalizeZ\",\n      value: function normalizeZ(points) {\n        var toInv = Fp.invertBatch(points.map(function (p) {\n          return p.ez;\n        }));\n        return points.map(function (p, i) {\n          return p.toAffine(toInv[i]);\n        }).map(Point.fromAffine);\n      }\n    }, {\n      key: \"fromHex\",\n      value: function fromHex(hex) {\n        var zip215 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var d = CURVE.d,\n          a = CURVE.a;\n        var len = Fp.BYTES;\n        hex = (0, utils_js_1.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n        var normed = hex.slice(); // copy again, we'll manipulate it\n        var lastByte = hex[len - 1]; // select last byte\n        normed[len - 1] = lastByte & ~0x80; // clear last bit\n        var y = ut.bytesToNumberLE(normed);\n        if (y === _0n) {\n          // y=0 is allowed\n        } else {\n          // RFC8032 prohibits >= p, but ZIP215 doesn't\n          if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n          else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n        }\n        // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n        // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n        var y2 = modP(y * y); // denominator is always non-0 mod p.\n        var u = modP(y2 - _1n); // u = y² - 1\n        var v = modP(d * y2 - a); // v = d y² + 1.\n        var _uvRatio = uvRatio(u, v),\n          isValid = _uvRatio.isValid,\n          x = _uvRatio.value; // √(u/v)\n        if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n        var isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n        var isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === _0n && isLastByteOdd)\n          // if x=0 and x_0 = 1, fail\n          throw new Error('Point.fromHex: x=0 and x_0=1');\n        if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n        return Point.fromAffine({\n          x: x,\n          y: y\n        });\n      }\n    }, {\n      key: \"fromPrivateKey\",\n      value: function fromPrivateKey(privKey) {\n        return getExtendedPublicKey(privKey).point;\n      }\n    }]);\n    return Point;\n  }();\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n  Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n  var G = Point.BASE,\n    I = Point.ZERO;\n  var wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);\n  function modN(a) {\n    return (0, modular_js_1.mod)(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash) {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key) {\n    var len = nByteLength;\n    key = (0, utils_js_1.ensureBytes)('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    var hashed = (0, utils_js_1.ensureBytes)('hashed private key', cHash(key), 2 * len);\n    var head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    var prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    var scalar = modN_LE(head); // The actual private scalar\n    var point = G.multiply(scalar); // Point on Edwards curve aka public key\n    var pointBytes = point.toRawBytes(); // Uint8Array representation\n    return {\n      head: head,\n      prefix: prefix,\n      scalar: scalar,\n      point: point,\n      pointBytes: pointBytes\n    };\n  }\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey) {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      msgs[_key - 1] = arguments[_key];\n    }\n    var msg = ut.concatBytes.apply(ut, msgs);\n    return modN_LE(cHash(domain(msg, (0, utils_js_1.ensureBytes)('context', context), !!prehash)));\n  }\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg, privKey) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    msg = (0, utils_js_1.ensureBytes)('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    var _getExtendedPublicKey = getExtendedPublicKey(privKey),\n      prefix = _getExtendedPublicKey.prefix,\n      scalar = _getExtendedPublicKey.scalar,\n      pointBytes = _getExtendedPublicKey.pointBytes;\n    var r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    var R = G.multiply(r).toRawBytes(); // R = rG\n    var k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    var s = modN(r + k * scalar); // S = (r + k * s) mod L\n    assertGE0(s); // 0 <= s < l\n    var res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return (0, utils_js_1.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature\n  }\n\n  var verifyOpts = VERIFY_DEFAULT;\n  function verify(sig, msg, publicKey) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : verifyOpts;\n    var context = options.context,\n      zip215 = options.zip215;\n    var len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = (0, utils_js_1.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = (0, utils_js_1.ensureBytes)('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n    var s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    // zip215: true is good for consensus-critical apps and allows points < 2^256\n    // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n    var A, R, SB;\n    try {\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n    var k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    var RkA = R.add(A.multiplyUnsafe(k));\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  var utils = {\n    getExtendedPublicKey: getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: function randomPrivateKey() {\n      return randomBytes(Fp.BYTES);\n    },\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute: function precompute() {\n      var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n      var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    }\n  };\n  return {\n    CURVE: CURVE,\n    getPublicKey: getPublicKey,\n    sign: sign,\n    verify: verify,\n    ExtendedPoint: Point,\n    utils: utils\n  };\n}\nexports.twistedEdwards = twistedEdwards;","map":null,"metadata":{},"sourceType":"script"}