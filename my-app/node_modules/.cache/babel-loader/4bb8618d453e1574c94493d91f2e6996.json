{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _objectSpread = require(\"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hash_to_ristretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.edwardsToMontgomeryPriv = exports.edwardsToMontgomery = exports.edwardsToMontgomeryPub = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar sha512_1 = require(\"@noble/hashes/sha512\");\nvar utils_1 = require(\"@noble/hashes/utils\");\nvar edwards_js_1 = require(\"./abstract/edwards.js\");\nvar montgomery_js_1 = require(\"./abstract/montgomery.js\");\nvar modular_js_1 = require(\"./abstract/modular.js\");\nvar utils_js_1 = require(\"./abstract/utils.js\");\nvar hash_to_curve_js_1 = require(\"./abstract/hash-to-curve.js\");\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nvar ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)\nvar ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nvar _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _5n = BigInt(5);\n// prettier-ignore\nvar _10n = BigInt(10),\n  _20n = BigInt(20),\n  _40n = BigInt(40),\n  _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n  var P = ED25519_P;\n  var x2 = x * x % P;\n  var b2 = x2 * x % P; // x^3, 11\n  var b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111\n  var b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P; // x^31\n  var b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;\n  var b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;\n  var b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;\n  var b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;\n  var b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;\n  var b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;\n  var b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;\n  var pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return {\n    pow_p_5_8: pow_p_5_8,\n    b2: b2\n  };\n}\nfunction adjustScalarBytes(bytes) {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n  var P = ED25519_P;\n  var v3 = (0, modular_js_1.mod)(v * v * v, P); // v¬≥\n  var v7 = (0, modular_js_1.mod)(v3 * v3 * v, P); // v‚Å∑\n  // (p+3)/8 and (p-5)/8\n  var pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  var x = (0, modular_js_1.mod)(u * v3 * pow, P); // (uv¬≥)(uv‚Å∑)^(p-5)/8\n  var vx2 = (0, modular_js_1.mod)(v * x * x, P); // vx¬≤\n  var root1 = x; // First root candidate\n  var root2 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n  var useRoot1 = vx2 === u; // If vx¬≤ = u (mod p), x is a square root\n  var useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P); // If vx¬≤ = -u, set x <-- x * 2^((p-1)/4)\n  var noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx¬≤ = -u‚àö(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if ((0, modular_js_1.isNegativeLE)(x, P)) x = (0, modular_js_1.mod)(-x, P);\n  return {\n    isValid: useRoot1 || useRoot2,\n    value: x\n  };\n}\n// Just in case\nexports.ED25519_TORSION_SUBGROUP = ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'];\nvar Fp = (0, modular_js_1.Field)(ED25519_P, undefined, true);\nvar ed25519Defaults = {\n  // Param: a\n  a: BigInt(-1),\n  // d is equal to -121665/121666 over finite field.\n  // Negative number is P - number, and division is invert(number, P)\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  // Finite field ùîΩp over which we'll do calculations; 2n**255n - 19n\n  Fp: Fp,\n  // Subgroup order: how many points curve has\n  // 2n**252n + 27742317777372353535851937790883648493n;\n  n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n  // Cofactor\n  h: BigInt(8),\n  // Base point (x, y) aka generator point\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n  hash: sha512_1.sha512,\n  randomBytes: utils_1.randomBytes,\n  adjustScalarBytes: adjustScalarBytes,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/‚àöv\n  uvRatio: uvRatio\n};\nexports.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nexports.ed25519ctx = (0, edwards_js_1.twistedEdwards)(_objectSpread({}, ed25519Defaults, {\n  domain: ed25519_domain\n}));\nexports.ed25519ph = (0, edwards_js_1.twistedEdwards)(_objectSpread({}, ed25519Defaults, {\n  domain: ed25519_domain,\n  prehash: sha512_1.sha512\n}));\nexports.x25519 = function () {\n  return (0, montgomery_js_1.montgomery)({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255,\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: function powPminus2(x) {\n      var P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      var _ed25519_pow_2_252_ = ed25519_pow_2_252_3(x),\n        pow_p_5_8 = _ed25519_pow_2_252_.pow_p_5_8,\n        b2 = _ed25519_pow_2_252_.b2;\n      return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes: adjustScalarBytes,\n    randomBytes: utils_1.randomBytes\n  });\n}();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n  var _exports$ed25519$Exte = exports.ed25519.ExtendedPoint.fromHex(edwardsPub),\n    y = _exports$ed25519$Exte.y;\n  var _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;\nexports.edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n  var hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\nexports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nvar ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nvar ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nvar ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nvar ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nvar ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n  var tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n  var xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  var x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  var tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n  var gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n  var gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  var tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  var y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  var y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n  var e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n  var y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  var x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  var y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n  var y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  var gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n  var e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n  var y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n  var e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n  var xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  var y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  var e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return {\n    xMn: xn,\n    xMd: xd,\n    yMn: y,\n    yMd: _1n\n  }; //  39. return (xn, xd, y, 1)\n}\n\nvar ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n  var _map_to_curve_elligat = map_to_curve_elligator2_curve25519(u),\n    xMn = _map_to_curve_elligat.xMn,\n    xMd = _map_to_curve_elligat.xMd,\n    yMn = _map_to_curve_elligat.yMn,\n    yMd = _map_to_curve_elligat.yMd; //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  var xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  var xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  var yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  var yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  var tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  var e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  var inv = Fp.invertBatch([xd, yd]); // batch division\n  return {\n    x: Fp.mul(xn, inv[0]),\n    y: Fp.mul(yn, inv[1])\n  }; //  13. return (xn, xd, yn, yd)\n}\n\nvar htf = /* @__PURE__ */function () {\n  return (0, hash_to_curve_js_1.createHasher)(exports.ed25519.ExtendedPoint, function (scalars) {\n    return map_to_curve_elligator2_edwards25519(scalars[0]);\n  }, {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512_1.sha512\n  });\n}();\nexports.hashToCurve = function () {\n  return htf.hashToCurve;\n}();\nexports.encodeToCurve = function () {\n  return htf.encodeToCurve;\n}();\nfunction assertRstPoint(other) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)\nvar SQRT_M1 = ED25519_SQRT_M1;\n// ‚àö(ad - 1)\nvar SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / ‚àö(a-d)\nvar INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d¬≤\nvar ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)¬≤\nvar D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/‚àö(number)\nvar invertSqrt = function invertSqrt(number) {\n  return uvRatio(_1n, number);\n};\nvar MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nvar bytes255ToNumberLE = function bytes255ToNumberLE(bytes) {\n  return exports.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);\n};\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n  var d = exports.ed25519.CURVE.d;\n  var P = exports.ed25519.CURVE.Fp.ORDER;\n  var mod = exports.ed25519.CURVE.Fp.create;\n  var r = mod(SQRT_M1 * r0 * r0); // 1\n  var Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  var c = BigInt(-1); // 3\n  var D = mod((c - d * r) * mod(r + d)); // 4\n  var _uvRatio = uvRatio(Ns, D),\n    Ns_D_is_sq = _uvRatio.isValid,\n    s = _uvRatio.value; // 5\n  var s_ = mod(s * r0); // 6\n  if (!(0, modular_js_1.isNegativeLE)(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  var Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  var s2 = s * s;\n  var W0 = mod((s + s) * D); // 10\n  var W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  var W2 = mod(_1n - s2); // 12\n  var W3 = mod(_1n + s2); // 13\n  return new exports.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nvar RistPoint = /*#__PURE__*/function () {\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  function RistPoint(ep) {\n    _classCallCheck(this, RistPoint);\n    this.ep = ep;\n  }\n  _createClass(RistPoint, [{\n    key: \"toRawBytes\",\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    value: function toRawBytes() {\n      var _this$ep = this.ep,\n        x = _this$ep.ex,\n        y = _this$ep.ey,\n        z = _this$ep.ez,\n        t = _this$ep.et;\n      var P = exports.ed25519.CURVE.Fp.ORDER;\n      var mod = exports.ed25519.CURVE.Fp.create;\n      var u1 = mod(mod(z + y) * mod(z - y)); // 1\n      var u2 = mod(x * y); // 2\n      // Square root always exists\n      var u2sq = mod(u2 * u2);\n      var _invertSqrt = invertSqrt(mod(u1 * u2sq)),\n        invsqrt = _invertSqrt.value; // 3\n      var D1 = mod(invsqrt * u1); // 4\n      var D2 = mod(invsqrt * u2); // 5\n      var zInv = mod(D1 * D2 * t); // 6\n      var D; // 7\n      if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {\n        var _x = mod(y * SQRT_M1);\n        var _y = mod(x * SQRT_M1);\n        x = _x;\n        y = _y;\n        D = mod(D1 * INVSQRT_A_MINUS_D);\n      } else {\n        D = D2; // 8\n      }\n\n      if ((0, modular_js_1.isNegativeLE)(x * zInv, P)) y = mod(-y); // 9\n      var s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n      if ((0, modular_js_1.isNegativeLE)(s, P)) s = mod(-s);\n      return (0, utils_js_1.numberToBytesLE)(s, 32); // 11\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return (0, utils_js_1.bytesToHex)(this.toRawBytes());\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toHex();\n    } // Compare one point to another.\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      assertRstPoint(other);\n      var _this$ep2 = this.ep,\n        X1 = _this$ep2.ex,\n        Y1 = _this$ep2.ey;\n      var _other$ep = other.ep,\n        X2 = _other$ep.ex,\n        Y2 = _other$ep.ey;\n      var mod = exports.ed25519.CURVE.Fp.create;\n      // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n      var one = mod(X1 * Y2) === mod(Y1 * X2);\n      var two = mod(Y1 * Y2) === mod(X1 * X2);\n      return one || two;\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      assertRstPoint(other);\n      return new RistPoint(this.ep.add(other.ep));\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      assertRstPoint(other);\n      return new RistPoint(this.ep.subtract(other.ep));\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return new RistPoint(this.ep.multiply(scalar));\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n  }], [{\n    key: \"fromAffine\",\n    value: function fromAffine(ap) {\n      return new RistPoint(exports.ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n  }, {\n    key: \"hashToCurve\",\n    value: function hashToCurve(hex) {\n      hex = (0, utils_js_1.ensureBytes)('ristrettoHash', hex, 64);\n      var r1 = bytes255ToNumberLE(hex.slice(0, 32));\n      var R1 = calcElligatorRistrettoMap(r1);\n      var r2 = bytes255ToNumberLE(hex.slice(32, 64));\n      var R2 = calcElligatorRistrettoMap(r2);\n      return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      hex = (0, utils_js_1.ensureBytes)('ristrettoHex', hex, 32);\n      var _exports$ed25519$CURV = exports.ed25519.CURVE,\n        a = _exports$ed25519$CURV.a,\n        d = _exports$ed25519$CURV.d;\n      var P = exports.ed25519.CURVE.Fp.ORDER;\n      var mod = exports.ed25519.CURVE.Fp.create;\n      var emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n      var s = bytes255ToNumberLE(hex);\n      // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n      // 3. Check that s is non-negative, or else abort\n      if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P)) throw new Error(emsg);\n      var s2 = mod(s * s);\n      var u1 = mod(_1n + a * s2); // 4 (a is -1)\n      var u2 = mod(_1n - a * s2); // 5\n      var u1_2 = mod(u1 * u1);\n      var u2_2 = mod(u2 * u2);\n      var v = mod(a * d * u1_2 - u2_2); // 6\n      var _invertSqrt2 = invertSqrt(mod(v * u2_2)),\n        isValid = _invertSqrt2.isValid,\n        I = _invertSqrt2.value; // 7\n      var Dx = mod(I * u2); // 8\n      var Dy = mod(I * Dx * v); // 9\n      var x = mod((s + s) * Dx); // 10\n      if ((0, modular_js_1.isNegativeLE)(x, P)) x = mod(-x); // 10\n      var y = mod(u1 * Dy); // 11\n      var t = mod(x * y); // 12\n      if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n) throw new Error(emsg);\n      return new RistPoint(new exports.ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n  }]);\n  return RistPoint;\n}();\nexports.RistrettoPoint = function () {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(exports.ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(exports.ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n}();\n// https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/14/\n// Appendix B.  Hashing to ristretto255\nvar hash_to_ristretto255 = function hash_to_ristretto255(msg, options) {\n  var d = options.DST;\n  var DST = typeof d === 'string' ? (0, utils_1.utf8ToBytes)(d) : d;\n  var uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);\n  var P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\nexports.hash_to_ristretto255 = hash_to_ristretto255;","map":null,"metadata":{},"sourceType":"script"}