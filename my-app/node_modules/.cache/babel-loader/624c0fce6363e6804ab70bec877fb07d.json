{"ast":null,"code":"import _get from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _asyncToGenerator from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toArray from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _createClass from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _wrapNativeSuper from \"/home/conel0826/theblokc-solana-dev-bootcamp/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(toFailures),\n  _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(run);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { Buffer as Buffer$1 } from 'buffer';\nimport { PublicKey, Transaction, TransactionInstruction, SendTransactionError, NONCE_ACCOUNT_LENGTH, SystemProgram, SYSVAR_RENT_PUBKEY, SYSVAR_CLOCK_PUBKEY } from '@solana/web3.js';\nimport * as web3_js from '@solana/web3.js';\nexport { web3_js as web3 };\nimport BN from 'bn.js';\nexport { default as BN } from 'bn.js';\nimport bs58$1 from 'bs58';\nimport * as base64$1 from 'base64-js';\nimport camelCase from 'camelcase';\nimport { sha256 as sha256$1 } from 'js-sha256';\nimport * as borsh from '@coral-xyz/borsh';\nimport { inflate } from 'pako';\nimport EventEmitter from 'eventemitter3';\nimport * as assert$1 from 'assert';\n\n/**\n * Splits an array into chunks\n *\n * @param array Array of objects to chunk.\n * @param size The max size of a chunk.\n * @returns A two dimensional array where each T[] length is < the provided size.\n */\nfunction chunks(array, size) {\n  return Array.apply(0, new Array(Math.ceil(array.length / size))).map(function (_, index) {\n    return array.slice(index * size, (index + 1) * size);\n  });\n}\nfunction encode$3(data) {\n  return data.reduce(function (str, byte) {\n    return str + byte.toString(16).padStart(2, \"0\");\n  }, \"0x\");\n}\nfunction decode$3(data) {\n  if (data.indexOf(\"0x\") === 0) {\n    data = data.substr(2);\n  }\n  if (data.length % 2 === 1) {\n    data = \"0\" + data;\n  }\n  var key = data.match(/.{2}/g);\n  if (key === null) {\n    return Buffer$1.from([]);\n  }\n  return Buffer$1.from(key.map(function (byte) {\n    return parseInt(byte, 16);\n  }));\n}\nvar hex = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  encode: encode$3,\n  decode: decode$3\n});\nfunction decode$2(array) {\n  var decoder = new TextDecoder(\"utf-8\") // Browser https://caniuse.com/textencoder.\n  ; // Node.\n  return decoder.decode(array);\n}\nfunction encode$2(input) {\n  var encoder = new TextEncoder() // Browser.\n  ; // Node.\n  return encoder.encode(input);\n}\nvar utf8 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  decode: decode$2,\n  encode: encode$2\n});\nfunction encode$1(data) {\n  return bs58$1.encode(data);\n}\nfunction decode$1(data) {\n  return bs58$1.decode(data);\n}\nvar bs58 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  encode: encode$1,\n  decode: decode$1\n});\nfunction encode(data) {\n  return base64$1.fromByteArray(data);\n}\nfunction decode(data) {\n  return Buffer$1.from(base64$1.toByteArray(data));\n}\nvar base64 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  encode: encode,\n  decode: decode\n});\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  hex: hex,\n  utf8: utf8,\n  bs58: bs58,\n  base64: base64\n});\nfunction parseIdlErrors(idl) {\n  var errors = new Map();\n  if (idl.errors) {\n    idl.errors.forEach(function (e) {\n      var _a;\n      var msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n      errors.set(e.code, msg);\n    });\n  }\n  return errors;\n}\n// Allow either IdLInstruction or IdlStateMethod since the types share fields.\nfunction toInstruction(idlIx) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n  var ix = {};\n  var idx = 0;\n  idlIx.args.forEach(function (ixArg) {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n  return ix;\n}\n// Throws error if any account required for the `ix` is not given.\nfunction validateAccounts(ixAccounts) {\n  var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  ixAccounts.forEach(function (acc) {\n    if (\"accounts\" in acc) {\n      validateAccounts(acc.accounts, accounts[acc.name]);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(\"Invalid arguments: \".concat(acc.name, \" not provided.\"));\n      }\n    }\n  });\n}\n// Translates an address to a Pubkey.\nfunction translateAddress(address) {\n  return address instanceof PublicKey ? address : new PublicKey(address);\n}\n\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inherits(StructError, _TypeError);\n  function StructError(failure, failures) {\n    var _this;\n    _classCallCheck(this, StructError);\n    var cached;\n    var message = failure.message,\n      rest = _objectWithoutProperties(failure, [\"message\"]);\n    var path = failure.path;\n    var msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StructError).call(this, msg));\n    _this.value = void 0;\n    _this.key = void 0;\n    _this.type = void 0;\n    _this.refinement = void 0;\n    _this.path = void 0;\n    _this.branch = void 0;\n    _this.failures = void 0;\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), rest);\n    _this.name = _this.constructor.name;\n    _this.failures = function () {\n      var _cached;\n      return (_cached = cached) != null ? _cached : cached = [failure].concat(_toConsumableArray(failures()));\n    };\n    return _this;\n  }\n  return StructError;\n}(_wrapNativeSuper(TypeError));\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  var _input$next = input.next(),\n    done = _input$next.done,\n    value = _input$next.value;\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n  var path = context.path,\n    branch = context.branch;\n  var type = struct.type;\n  var _result = result,\n    refinement = _result.refinement,\n    _result$message = _result.message,\n    message = _result$message === void 0 ? \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\" : _result$message;\n  return _objectSpread({\n    value: value,\n    type: type,\n    refinement: refinement,\n    key: path[path.length - 1],\n    path: path,\n    branch: branch\n  }, result, {\n    message: message\n  });\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction toFailures(result, context, struct, value) {\n  var _iterator, _step, r, failure;\n  return _regeneratorRuntime().wrap(function toFailures$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (!isIterable(result)) {\n          result = [result];\n        }\n        _iterator = _createForOfIteratorHelper(result);\n        _context.prev = 2;\n        _iterator.s();\n      case 4:\n        if ((_step = _iterator.n()).done) {\n          _context.next = 12;\n          break;\n        }\n        r = _step.value;\n        failure = toFailure(r, context, struct, value);\n        if (!failure) {\n          _context.next = 10;\n          break;\n        }\n        _context.next = 10;\n        return failure;\n      case 10:\n        _context.next = 4;\n        break;\n      case 12:\n        _context.next = 17;\n        break;\n      case 14:\n        _context.prev = 14;\n        _context.t0 = _context[\"catch\"](2);\n        _iterator.e(_context.t0);\n      case 17:\n        _context.prev = 17;\n        _iterator.f();\n        return _context.finish(17);\n      case 20:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[2, 14, 17, 20]]);\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction run(value, struct, options) {\n  var _options, _options$path, path, _options$branch, branch, _options$coerce, coerce, _options$mask, mask, ctx, key, valid, _iterator2, _step2, _failure, _iterator3, _step3, _step3$value, k, v, s, ts, _iterator5, _step5, t, _iterator4, _step4, failure;\n  return _regeneratorRuntime().wrap(function run$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        if (options === void 0) {\n          options = {};\n        }\n        _options = options, _options$path = _options.path, path = _options$path === void 0 ? [] : _options$path, _options$branch = _options.branch, branch = _options$branch === void 0 ? [value] : _options$branch, _options$coerce = _options.coerce, coerce = _options$coerce === void 0 ? false : _options$coerce, _options$mask = _options.mask, mask = _options$mask === void 0 ? false : _options$mask;\n        ctx = {\n          path: path,\n          branch: branch\n        };\n        if (coerce) {\n          value = struct.coercer(value, ctx);\n          if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for (key in value) {\n              if (struct.schema[key] === undefined) {\n                delete value[key];\n              }\n            }\n          }\n        }\n        valid = true;\n        _iterator2 = _createForOfIteratorHelper(struct.validator(value, ctx));\n        _context2.prev = 6;\n        _iterator2.s();\n      case 8:\n        if ((_step2 = _iterator2.n()).done) {\n          _context2.next = 15;\n          break;\n        }\n        _failure = _step2.value;\n        valid = false;\n        _context2.next = 13;\n        return [_failure, undefined];\n      case 13:\n        _context2.next = 8;\n        break;\n      case 15:\n        _context2.next = 20;\n        break;\n      case 17:\n        _context2.prev = 17;\n        _context2.t0 = _context2[\"catch\"](6);\n        _iterator2.e(_context2.t0);\n      case 20:\n        _context2.prev = 20;\n        _iterator2.f();\n        return _context2.finish(20);\n      case 23:\n        _iterator3 = _createForOfIteratorHelper(struct.entries(value, ctx));\n        _context2.prev = 24;\n        _iterator3.s();\n      case 26:\n        if ((_step3 = _iterator3.n()).done) {\n          _context2.next = 53;\n          break;\n        }\n        _step3$value = _slicedToArray(_step3.value, 3), k = _step3$value[0], v = _step3$value[1], s = _step3$value[2];\n        ts = run(v, s, {\n          path: k === undefined ? path : [].concat(_toConsumableArray(path), [k]),\n          branch: k === undefined ? branch : [].concat(_toConsumableArray(branch), [v]),\n          coerce: coerce,\n          mask: mask\n        });\n        _iterator5 = _createForOfIteratorHelper(ts);\n        _context2.prev = 30;\n        _iterator5.s();\n      case 32:\n        if ((_step5 = _iterator5.n()).done) {\n          _context2.next = 43;\n          break;\n        }\n        t = _step5.value;\n        if (!t[0]) {\n          _context2.next = 40;\n          break;\n        }\n        valid = false;\n        _context2.next = 38;\n        return [t[0], undefined];\n      case 38:\n        _context2.next = 41;\n        break;\n      case 40:\n        if (coerce) {\n          v = t[1];\n          if (k === undefined) {\n            value = v;\n          } else if (value instanceof Map) {\n            value.set(k, v);\n          } else if (value instanceof Set) {\n            value.add(v);\n          } else if (isObject(value)) {\n            value[k] = v;\n          }\n        }\n      case 41:\n        _context2.next = 32;\n        break;\n      case 43:\n        _context2.next = 48;\n        break;\n      case 45:\n        _context2.prev = 45;\n        _context2.t1 = _context2[\"catch\"](30);\n        _iterator5.e(_context2.t1);\n      case 48:\n        _context2.prev = 48;\n        _iterator5.f();\n        return _context2.finish(48);\n      case 51:\n        _context2.next = 26;\n        break;\n      case 53:\n        _context2.next = 58;\n        break;\n      case 55:\n        _context2.prev = 55;\n        _context2.t2 = _context2[\"catch\"](24);\n        _iterator3.e(_context2.t2);\n      case 58:\n        _context2.prev = 58;\n        _iterator3.f();\n        return _context2.finish(58);\n      case 61:\n        if (!valid) {\n          _context2.next = 80;\n          break;\n        }\n        _iterator4 = _createForOfIteratorHelper(struct.refiner(value, ctx));\n        _context2.prev = 63;\n        _iterator4.s();\n      case 65:\n        if ((_step4 = _iterator4.n()).done) {\n          _context2.next = 72;\n          break;\n        }\n        failure = _step4.value;\n        valid = false;\n        _context2.next = 70;\n        return [failure, undefined];\n      case 70:\n        _context2.next = 65;\n        break;\n      case 72:\n        _context2.next = 77;\n        break;\n      case 74:\n        _context2.prev = 74;\n        _context2.t3 = _context2[\"catch\"](63);\n        _iterator4.e(_context2.t3);\n      case 77:\n        _context2.prev = 77;\n        _iterator4.f();\n        return _context2.finish(77);\n      case 80:\n        if (!valid) {\n          _context2.next = 83;\n          break;\n        }\n        _context2.next = 83;\n        return [undefined, value];\n      case 83:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _marked2, null, [[6, 17, 20, 23], [24, 55, 58, 61], [30, 45, 48, 51], [63, 74, 77, 80]]);\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nvar Struct = /*#__PURE__*/function () {\n  function Struct(props) {\n    var _this2 = this;\n    _classCallCheck(this, Struct);\n    this.TYPE = void 0;\n    this.type = void 0;\n    this.schema = void 0;\n    this.coercer = void 0;\n    this.validator = void 0;\n    this.refiner = void 0;\n    this.entries = void 0;\n    var type = props.type,\n      schema = props.schema,\n      validator = props.validator,\n      refiner = props.refiner,\n      _props$coercer = props.coercer,\n      coercer = _props$coercer === void 0 ? function (value) {\n        return value;\n      } : _props$coercer,\n      _props$entries = props.entries,\n      entries = _props$entries === void 0 ? /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee);\n      }) : _props$entries;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = function (value, context) {\n        var result = validator(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.validator = function () {\n        return [];\n      };\n    }\n    if (refiner) {\n      this.refiner = function (value, context) {\n        var result = refiner(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.refiner = function () {\n        return [];\n      };\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  _createClass(Struct, [{\n    key: \"assert\",\n    value: function assert(value) {\n      return _assert(value, this);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n  }, {\n    key: \"create\",\n    value: function create(value) {\n      return _create(value, this);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n  }, {\n    key: \"is\",\n    value: function is(value) {\n      return _is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n  }, {\n    key: \"mask\",\n    value: function mask(value) {\n      return _mask(value, this);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n  }, {\n    key: \"validate\",\n    value: function validate(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      return _validate(value, this, options);\n    }\n  }]);\n  return Struct;\n}();\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction _assert(value, struct) {\n  var result = _validate(value, struct);\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction _create(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction _mask(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction _is(value, struct) {\n  var result = _validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction _validate(value, struct, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var tuples = run(value, struct, options);\n  var tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    var error = new StructError(tuple[0], /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var _iterator6, _step6, t;\n      return _regeneratorRuntime().wrap(function _callee2$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _iterator6 = _createForOfIteratorHelper(tuples);\n            _context4.prev = 1;\n            _iterator6.s();\n          case 3:\n            if ((_step6 = _iterator6.n()).done) {\n              _context4.next = 10;\n              break;\n            }\n            t = _step6.value;\n            if (!t[0]) {\n              _context4.next = 8;\n              break;\n            }\n            _context4.next = 8;\n            return t[0];\n          case 8:\n            _context4.next = 3;\n            break;\n          case 10:\n            _context4.next = 15;\n            break;\n          case 12:\n            _context4.prev = 12;\n            _context4.t0 = _context4[\"catch\"](1);\n            _iterator6.e(_context4.t0);\n          case 15:\n            _context4.prev = 15;\n            _iterator6.f();\n            return _context4.finish(15);\n          case 18:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee2, null, [[1, 12, 15, 18]]);\n    }));\n    return [error, undefined];\n  } else {\n    var v = tuple[1];\n    return [undefined, v];\n  }\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator: validator\n  });\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', function () {\n    return true;\n  });\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _iterator7, _step7, _step7$value, i, v;\n      return _regeneratorRuntime().wrap(function entries$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!(Element && Array.isArray(value))) {\n              _context5.next = 18;\n              break;\n            }\n            _iterator7 = _createForOfIteratorHelper(value.entries());\n            _context5.prev = 2;\n            _iterator7.s();\n          case 4:\n            if ((_step7 = _iterator7.n()).done) {\n              _context5.next = 10;\n              break;\n            }\n            _step7$value = _slicedToArray(_step7.value, 2), i = _step7$value[0], v = _step7$value[1];\n            _context5.next = 8;\n            return [i, v, Element];\n          case 8:\n            _context5.next = 4;\n            break;\n          case 10:\n            _context5.next = 15;\n            break;\n          case 12:\n            _context5.prev = 12;\n            _context5.t0 = _context5[\"catch\"](2);\n            _iterator7.e(_context5.t0);\n          case 15:\n            _context5.prev = 15;\n            _iterator7.f();\n            return _context5.finish(15);\n          case 18:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', function (value) {\n    return typeof value === 'boolean';\n  });\n}\nfunction literal(constant) {\n  var description = print(constant);\n  var t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator: function validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct(_objectSpread({}, struct, {\n    validator: function validator(value, ctx) {\n      return value === null || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === null || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', function (value) {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct(_objectSpread({}, struct, {\n    validator: function validator(value, ctx) {\n      return value === undefined || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', function (value) {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  var keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema: schema,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _i, _keys, k;\n      return _regeneratorRuntime().wrap(function entries$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!isObject(value)) {\n              _context6.next = 9;\n              break;\n            }\n            _i = 0, _keys = keys;\n          case 2:\n            if (!(_i < _keys.length)) {\n              _context6.next = 9;\n              break;\n            }\n            k = _keys[_i];\n            _context6.next = 6;\n            return [k, value[k], schema[k]];\n          case 6:\n            _i++;\n            _context6.next = 2;\n            break;\n          case 9:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nfunction union$1(Structs) {\n  var description = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer: function coercer(value, ctx) {\n      var firstMatch = Structs.find(function (s) {\n        var _s$validate = s.validate(value, {\n            coerce: true\n          }),\n          _s$validate2 = _slicedToArray(_s$validate, 1),\n          e = _s$validate2[0];\n        return !e;\n      }) || unknown();\n      return firstMatch.coercer(value, ctx);\n    },\n    validator: function validator(value, ctx) {\n      var failures = [];\n      var _iterator8 = _createForOfIteratorHelper(Structs),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var S = _step8.value;\n          var _run = run(value, S, ctx),\n            _run2 = _toArray(_run),\n            tuples = _run2.slice(0);\n          var _tuples = _slicedToArray(tuples, 1),\n            first = _tuples[0];\n          if (!first[0]) {\n            return [];\n          } else {\n            var _iterator9 = _createForOfIteratorHelper(tuples),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _step9$value = _slicedToArray(_step9.value, 1),\n                  failure = _step9$value[0];\n                if (failure) {\n                  failures.push(failure);\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value)].concat(failures);\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', function () {\n    return true;\n  });\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, _coercer) {\n  return new Struct(_objectSpread({}, struct, {\n    coercer: function coercer(value, ctx) {\n      return _is(value, condition) ? struct.coercer(_coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  }));\n}\n\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nfunction invoke(_x, _x2, _x3, _x4) {\n  return _invoke.apply(this, arguments);\n}\nfunction _invoke() {\n  _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54(programId, accounts, data, provider) {\n    var tx;\n    return _regeneratorRuntime().wrap(function _callee54$(_context59) {\n      while (1) switch (_context59.prev = _context59.next) {\n        case 0:\n          programId = translateAddress(programId);\n          if (!provider) {\n            provider = getProvider();\n          }\n          tx = new Transaction();\n          tx.add(new TransactionInstruction({\n            programId: programId,\n            keys: accounts !== null && accounts !== void 0 ? accounts : [],\n            data: data\n          }));\n          if (!(provider.sendAndConfirm === undefined)) {\n            _context59.next = 6;\n            break;\n          }\n          throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");\n        case 6:\n          _context59.next = 8;\n          return provider.sendAndConfirm(tx, []);\n        case 8:\n          return _context59.abrupt(\"return\", _context59.sent);\n        case 9:\n        case \"end\":\n          return _context59.stop();\n      }\n    }, _callee54);\n  }));\n  return _invoke.apply(this, arguments);\n}\nvar GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nfunction getMultipleAccounts(_x5, _x6, _x7) {\n  return _getMultipleAccounts.apply(this, arguments);\n}\nfunction _getMultipleAccounts() {\n  _getMultipleAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(connection, publicKeys, commitment) {\n    var results;\n    return _regeneratorRuntime().wrap(function _callee55$(_context60) {\n      while (1) switch (_context60.prev = _context60.next) {\n        case 0:\n          _context60.next = 2;\n          return getMultipleAccountsAndContext(connection, publicKeys, commitment);\n        case 2:\n          results = _context60.sent;\n          return _context60.abrupt(\"return\", results.map(function (result) {\n            return result ? {\n              publicKey: result.publicKey,\n              account: result.account\n            } : null;\n          }));\n        case 4:\n        case \"end\":\n          return _context60.stop();\n      }\n    }, _callee55);\n  }));\n  return _getMultipleAccounts.apply(this, arguments);\n}\nfunction getMultipleAccountsAndContext(_x8, _x9, _x10) {\n  return _getMultipleAccountsAndContext.apply(this, arguments);\n}\nfunction _getMultipleAccountsAndContext() {\n  _getMultipleAccountsAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56(connection, publicKeys, commitment) {\n    var batches, results;\n    return _regeneratorRuntime().wrap(function _callee56$(_context61) {\n      while (1) switch (_context61.prev = _context61.next) {\n        case 0:\n          if (!(publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT)) {\n            _context61.next = 6;\n            break;\n          }\n          _context61.next = 3;\n          return getMultipleAccountsAndContextCore(connection, publicKeys, commitment);\n        case 3:\n          return _context61.abrupt(\"return\", _context61.sent);\n        case 6:\n          batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n          _context61.next = 9;\n          return Promise.all(batches.map(function (batch) {\n            return getMultipleAccountsAndContextCore(connection, batch, commitment);\n          }));\n        case 9:\n          results = _context61.sent;\n          return _context61.abrupt(\"return\", results.flat());\n        case 11:\n        case \"end\":\n          return _context61.stop();\n      }\n    }, _callee56);\n  }));\n  return _getMultipleAccountsAndContext.apply(this, arguments);\n}\nfunction getMultipleAccountsAndContextCore(_x11, _x12, _x13) {\n  return _getMultipleAccountsAndContextCore.apply(this, arguments);\n} // copy from @solana/web3.js that has a commitment param\nfunction _getMultipleAccountsAndContextCore() {\n  _getMultipleAccountsAndContextCore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee57(connection, publicKeys, commitmentOverride) {\n    var commitment, _yield$connection$get, accountInfos, context, accounts;\n    return _regeneratorRuntime().wrap(function _callee57$(_context62) {\n      while (1) switch (_context62.prev = _context62.next) {\n        case 0:\n          commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;\n          _context62.next = 3;\n          return connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);\n        case 3:\n          _yield$connection$get = _context62.sent;\n          accountInfos = _yield$connection$get.value;\n          context = _yield$connection$get.context;\n          accounts = accountInfos.map(function (account, idx) {\n            if (account === null) {\n              return null;\n            }\n            return {\n              publicKey: publicKeys[idx],\n              account: account,\n              context: context\n            };\n          });\n          return _context62.abrupt(\"return\", accounts);\n        case 8:\n        case \"end\":\n          return _context62.stop();\n      }\n    }, _callee57);\n  }));\n  return _getMultipleAccountsAndContextCore.apply(this, arguments);\n}\nfunction simulateTransaction(_x14, _x15, _x16, _x17, _x18) {\n  return _simulateTransaction.apply(this, arguments);\n} // copy from @solana/web3.js\nfunction _simulateTransaction() {\n  _simulateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee58(connection, transaction, signers, commitment, includeAccounts) {\n    var message, signData, wireTransaction, encodedTransaction, config, addresses, args, unsafeRes, res, logs, traceIndent, logTrace;\n    return _regeneratorRuntime().wrap(function _callee58$(_context63) {\n      while (1) switch (_context63.prev = _context63.next) {\n        case 0:\n          if (signers && signers.length > 0) {\n            transaction.sign.apply(transaction, _toConsumableArray(signers));\n          }\n          // @ts-expect-error\n          message = transaction._compile();\n          signData = message.serialize(); // @ts-expect-error\n          wireTransaction = transaction._serialize(signData);\n          encodedTransaction = wireTransaction.toString(\"base64\");\n          config = {\n            encoding: \"base64\",\n            commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment\n          };\n          if (includeAccounts) {\n            addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(function (key) {\n              return key.toBase58();\n            });\n            config[\"accounts\"] = {\n              encoding: \"base64\",\n              addresses: addresses\n            };\n          }\n          if (signers) {\n            config.sigVerify = true;\n          }\n          args = [encodedTransaction, config]; // @ts-expect-error\n          _context63.next = 11;\n          return connection._rpcRequest(\"simulateTransaction\", args);\n        case 11:\n          unsafeRes = _context63.sent;\n          res = _create(unsafeRes, SimulatedTransactionResponseStruct);\n          if (!(\"error\" in res)) {\n            _context63.next = 16;\n            break;\n          }\n          if (\"data\" in res.error) {\n            logs = res.error.data.logs;\n            if (logs && Array.isArray(logs)) {\n              traceIndent = \"\\n    \";\n              logTrace = traceIndent + logs.join(traceIndent);\n              console.error(res.error.message, logTrace);\n            }\n          }\n          throw new SendTransactionError(\"failed to simulate transaction: \" + res.error.message, logs);\n        case 16:\n          return _context63.abrupt(\"return\", res.result);\n        case 17:\n        case \"end\":\n          return _context63.stop();\n      }\n    }, _callee58);\n  }));\n  return _simulateTransaction.apply(this, arguments);\n}\nfunction jsonRpcResult(schema) {\n  return coerce(createRpcResult(schema), UnknownRpcResult, function (value) {\n    if (\"error\" in value) {\n      return value;\n    } else {\n      return _objectSpread({}, value, {\n        result: _create(value.result, schema)\n      });\n    }\n  });\n}\n// copy from @solana/web3.js\nvar UnknownRpcResult = createRpcResult(unknown());\n// copy from @solana/web3.js\nfunction createRpcResult(result) {\n  return union$1([type({\n    jsonrpc: literal(\"2.0\"),\n    id: string(),\n    result: result\n  }), type({\n    jsonrpc: literal(\"2.0\"),\n    id: string(),\n    error: type({\n      code: unknown(),\n      message: string(),\n      data: optional(any())\n    })\n  })]);\n}\n// copy from @solana/web3.js\nfunction jsonRpcResultAndContext(value) {\n  return jsonRpcResult(type({\n    context: type({\n      slot: number()\n    }),\n    value: value\n  }));\n}\n// copy from @solana/web3.js\nvar SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({\n  err: nullable(union$1([type({}), string()])),\n  logs: nullable(array(string())),\n  accounts: optional(nullable(array(nullable(type({\n    executable: boolean(),\n    owner: string(),\n    lamports: number(),\n    data: array(string()),\n    rentEpoch: optional(number())\n  }))))),\n  unitsConsumed: optional(number())\n}));\nvar rpc = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  invoke: invoke,\n  getMultipleAccounts: getMultipleAccounts,\n  getMultipleAccountsAndContext: getMultipleAccountsAndContext,\n  simulateTransaction: simulateTransaction\n});\n\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nvar AnchorProvider = /*#__PURE__*/function () {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  function AnchorProvider(connection, wallet, opts) {\n    _classCallCheck(this, AnchorProvider);\n    this.connection = connection;\n    this.wallet = wallet;\n    this.opts = opts;\n    this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;\n  }\n  _createClass(AnchorProvider, [{\n    key: \"sendAndConfirm\",\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The signers of the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    value: function () {\n      var _sendAndConfirm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx, signers, opts) {\n        var _a, rawTx, failedTx, logs;\n        return _regeneratorRuntime().wrap(function _callee3$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (opts === undefined) {\n                opts = this.opts;\n              }\n              tx.feePayer = tx.feePayer || this.wallet.publicKey;\n              _context7.next = 4;\n              return this.connection.getLatestBlockhash(opts.preflightCommitment);\n            case 4:\n              tx.recentBlockhash = _context7.sent.blockhash;\n              _context7.next = 7;\n              return this.wallet.signTransaction(tx);\n            case 7:\n              tx = _context7.sent;\n              (signers !== null && signers !== void 0 ? signers : []).forEach(function (kp) {\n                tx.partialSign(kp);\n              });\n              rawTx = tx.serialize();\n              _context7.prev = 10;\n              _context7.next = 13;\n              return sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n            case 13:\n              return _context7.abrupt(\"return\", _context7.sent);\n            case 16:\n              _context7.prev = 16;\n              _context7.t0 = _context7[\"catch\"](10);\n              if (!(_context7.t0 instanceof ConfirmError)) {\n                _context7.next = 30;\n                break;\n              }\n              _context7.next = 21;\n              return this.connection.getTransaction(encode$1(tx.signature), {\n                commitment: \"confirmed\"\n              });\n            case 21:\n              failedTx = _context7.sent;\n              if (failedTx) {\n                _context7.next = 26;\n                break;\n              }\n              throw _context7.t0;\n            case 26:\n              logs = (_a = failedTx.meta) === null || _a === void 0 ? void 0 : _a.logMessages;\n              throw !logs ? _context7.t0 : new SendTransactionError(_context7.t0.message, logs);\n            case 28:\n              _context7.next = 31;\n              break;\n            case 30:\n              throw _context7.t0;\n            case 31:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee3, this, [[10, 16]]);\n      }));\n      function sendAndConfirm(_x19, _x20, _x21) {\n        return _sendAndConfirm.apply(this, arguments);\n      }\n      return sendAndConfirm;\n    }()\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     *\n     * @param txWithSigners Array of transactions and signers.\n     * @param opts          Transaction confirmation options.\n     */\n  }, {\n    key: \"sendAll\",\n    value: function () {\n      var _sendAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(txWithSigners, opts) {\n        var _this3 = this;\n        var _a, blockhash, txs, signedTxs, sigs, k, tx, rawTx, failedTx, logs;\n        return _regeneratorRuntime().wrap(function _callee4$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (opts === undefined) {\n                opts = this.opts;\n              }\n              _context8.next = 3;\n              return this.connection.getLatestBlockhash(opts.preflightCommitment);\n            case 3:\n              blockhash = _context8.sent;\n              txs = txWithSigners.map(function (r) {\n                var _a;\n                var tx = r.tx;\n                var signers = (_a = r.signers) !== null && _a !== void 0 ? _a : [];\n                tx.feePayer = tx.feePayer || _this3.wallet.publicKey;\n                tx.recentBlockhash = blockhash.blockhash;\n                signers.forEach(function (kp) {\n                  tx.partialSign(kp);\n                });\n                return tx;\n              });\n              _context8.next = 7;\n              return this.wallet.signAllTransactions(txs);\n            case 7:\n              signedTxs = _context8.sent;\n              sigs = [];\n              k = 0;\n            case 10:\n              if (!(k < txs.length)) {\n                _context8.next = 39;\n                break;\n              }\n              tx = signedTxs[k];\n              rawTx = tx.serialize();\n              _context8.prev = 13;\n              _context8.t0 = sigs;\n              _context8.next = 17;\n              return sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n            case 17:\n              _context8.t1 = _context8.sent;\n              _context8.t0.push.call(_context8.t0, _context8.t1);\n              _context8.next = 36;\n              break;\n            case 21:\n              _context8.prev = 21;\n              _context8.t2 = _context8[\"catch\"](13);\n              if (!(_context8.t2 instanceof ConfirmError)) {\n                _context8.next = 35;\n                break;\n              }\n              _context8.next = 26;\n              return this.connection.getTransaction(encode$1(tx.signature), {\n                commitment: \"confirmed\"\n              });\n            case 26:\n              failedTx = _context8.sent;\n              if (failedTx) {\n                _context8.next = 31;\n                break;\n              }\n              throw _context8.t2;\n            case 31:\n              logs = (_a = failedTx.meta) === null || _a === void 0 ? void 0 : _a.logMessages;\n              throw !logs ? _context8.t2 : new SendTransactionError(_context8.t2.message, logs);\n            case 33:\n              _context8.next = 36;\n              break;\n            case 35:\n              throw _context8.t2;\n            case 36:\n              k += 1;\n              _context8.next = 10;\n              break;\n            case 39:\n              return _context8.abrupt(\"return\", sigs);\n            case 40:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee4, this, [[13, 21]]);\n      }));\n      function sendAll(_x22, _x23) {\n        return _sendAll.apply(this, arguments);\n      }\n      return sendAll;\n    }()\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The signers of the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n  }, {\n    key: \"simulate\",\n    value: function () {\n      var _simulate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tx, signers, commitment, includeAccounts) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee5$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              tx.feePayer = tx.feePayer || this.wallet.publicKey;\n              _context9.next = 3;\n              return this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment);\n            case 3:\n              tx.recentBlockhash = _context9.sent.blockhash;\n              _context9.next = 6;\n              return this.wallet.signTransaction(tx);\n            case 6:\n              tx = _context9.sent;\n              _context9.next = 9;\n              return simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);\n            case 9:\n              result = _context9.sent;\n              if (!result.value.err) {\n                _context9.next = 12;\n                break;\n              }\n              throw new SimulateError(result.value);\n            case 12:\n              return _context9.abrupt(\"return\", result.value);\n            case 13:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee5, this);\n      }));\n      function simulate(_x24, _x25, _x26, _x27) {\n        return _simulate.apply(this, arguments);\n      }\n      return simulate;\n    }()\n  }], [{\n    key: \"defaultOptions\",\n    value: function defaultOptions() {\n      return {\n        preflightCommitment: \"processed\",\n        commitment: \"processed\"\n      };\n    }\n    /**\n     * Returns a `Provider` with a wallet read from the local filesystem.\n     *\n     * @param url  The network cluster url.\n     * @param opts The default transaction confirmation options.\n     *\n     * (This api is for Node only.)\n     */\n  }, {\n    key: \"local\",\n    value: function local(url, opts) {\n      {\n        throw new Error(\"Provider local is not available on browser.\");\n      }\n    }\n    /**\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n     * variable\n     *\n     * (This api is for Node only.)\n     */\n  }, {\n    key: \"env\",\n    value: function env() {\n      {\n        throw new Error(\"Provider env is not available on browser.\");\n      }\n    }\n  }]);\n  return AnchorProvider;\n}();\nvar SimulateError = /*#__PURE__*/function (_Error) {\n  _inherits(SimulateError, _Error);\n  function SimulateError(simulationResponse, message) {\n    var _this4;\n    _classCallCheck(this, SimulateError);\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(SimulateError).call(this, message));\n    _this4.simulationResponse = simulationResponse;\n    return _this4;\n  }\n  return SimulateError;\n}(_wrapNativeSuper(Error)); // Copy of Connection.sendAndConfirmRawTransaction that throws\n// a better error if 'confirmTransaction` returns an error status\nfunction sendAndConfirmRawTransaction(_x28, _x29, _x30) {\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\nfunction _sendAndConfirmRawTransaction() {\n  _sendAndConfirmRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee59(connection, rawTransaction, options) {\n    var sendOptions, signature, status;\n    return _regeneratorRuntime().wrap(function _callee59$(_context64) {\n      while (1) switch (_context64.prev = _context64.next) {\n        case 0:\n          sendOptions = options && {\n            skipPreflight: options.skipPreflight,\n            preflightCommitment: options.preflightCommitment || options.commitment\n          };\n          _context64.next = 3;\n          return connection.sendRawTransaction(rawTransaction, sendOptions);\n        case 3:\n          signature = _context64.sent;\n          _context64.next = 6;\n          return connection.confirmTransaction(signature, options && options.commitment);\n        case 6:\n          status = _context64.sent.value;\n          if (!status.err) {\n            _context64.next = 9;\n            break;\n          }\n          throw new ConfirmError(\"Raw transaction \".concat(signature, \" failed (\").concat(JSON.stringify(status), \")\"));\n        case 9:\n          return _context64.abrupt(\"return\", signature);\n        case 10:\n        case \"end\":\n          return _context64.stop();\n      }\n    }, _callee59);\n  }));\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\nvar ConfirmError = /*#__PURE__*/function (_Error2) {\n  _inherits(ConfirmError, _Error2);\n  function ConfirmError(message) {\n    _classCallCheck(this, ConfirmError);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ConfirmError).call(this, message));\n  }\n  return ConfirmError;\n}(_wrapNativeSuper(Error));\n/**\n * Sets the default provider on the client.\n */\nfunction setProvider(provider) {\n  _provider = provider;\n}\n/**\n * Returns the default provider being used by the client.\n */\nfunction getProvider() {\n  if (_provider === null) {\n    return AnchorProvider.local();\n  }\n  return _provider;\n}\n// Global provider used as the default when a provider is not given.\nvar _provider = null;\nvar _AVAILABLE_FEATURES = new Set([\"anchor-deprecated-state\", \"debug-logs\"]);\nvar _FEATURES = new Map();\nfunction set(key) {\n  if (!_AVAILABLE_FEATURES.has(key)) {\n    throw new Error(\"Invalid feature\");\n  }\n  _FEATURES.set(key, true);\n}\nfunction isSet(key) {\n  return _FEATURES.get(key) !== undefined;\n}\nvar features = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  set: set,\n  isSet: isSet\n});\nvar IdlError = /*#__PURE__*/function (_Error3) {\n  _inherits(IdlError, _Error3);\n  function IdlError(message) {\n    var _this5;\n    _classCallCheck(this, IdlError);\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(IdlError).call(this, message));\n    _this5.name = \"IdlError\";\n    return _this5;\n  }\n  return IdlError;\n}(_wrapNativeSuper(Error));\nvar ProgramErrorStack = /*#__PURE__*/function () {\n  function ProgramErrorStack(stack) {\n    _classCallCheck(this, ProgramErrorStack);\n    this.stack = stack;\n  }\n  _createClass(ProgramErrorStack, null, [{\n    key: \"parse\",\n    value: function parse(logs) {\n      var _a;\n      var programKeyRegex = /^Program (\\w*) invoke/;\n      var successRegex = /^Program \\w* success/;\n      var programStack = [];\n      for (var i = 0; i < logs.length; i++) {\n        if (successRegex.exec(logs[i])) {\n          programStack.pop();\n          continue;\n        }\n        var programKey = (_a = programKeyRegex.exec(logs[i])) === null || _a === void 0 ? void 0 : _a[1];\n        if (!programKey) {\n          continue;\n        }\n        programStack.push(new PublicKey(programKey));\n      }\n      return new ProgramErrorStack(programStack);\n    }\n  }]);\n  return ProgramErrorStack;\n}();\nvar AnchorError = /*#__PURE__*/function (_Error4) {\n  _inherits(AnchorError, _Error4);\n  function AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {\n    var _this6;\n    _classCallCheck(this, AnchorError);\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(AnchorError).call(this, errorLogs.join(\"\\n\").replace(\"Program log: \", \"\")));\n    _this6.errorLogs = errorLogs;\n    _this6.logs = logs;\n    _this6.error = {\n      errorCode: errorCode,\n      errorMessage: errorMessage,\n      comparedValues: comparedValues,\n      origin: origin\n    };\n    _this6._programErrorStack = ProgramErrorStack.parse(logs);\n    return _this6;\n  }\n  _createClass(AnchorError, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.message;\n    }\n  }, {\n    key: \"program\",\n    get: function get() {\n      return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];\n    }\n  }, {\n    key: \"programErrorStack\",\n    get: function get() {\n      return this._programErrorStack.stack;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(logs) {\n      if (!logs) {\n        return null;\n      }\n      var anchorErrorLogIndex = logs.findIndex(function (log) {\n        return log.startsWith(\"Program log: AnchorError\");\n      });\n      if (anchorErrorLogIndex === -1) {\n        return null;\n      }\n      var anchorErrorLog = logs[anchorErrorLogIndex];\n      var errorLogs = [anchorErrorLog];\n      var comparedValues;\n      if (anchorErrorLogIndex + 1 < logs.length) {\n        // This catches the comparedValues where the following is logged\n        // <AnchorError>\n        // Left:\n        // <Pubkey>\n        // Right:\n        // <Pubkey>\n        if (logs[anchorErrorLogIndex + 1] === \"Program log: Left:\") {\n          var pubkeyRegex = /^Program log: (.*)$/;\n          var leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];\n          var rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];\n          comparedValues = [new PublicKey(leftPubkey), new PublicKey(rightPubkey)];\n          errorLogs.push.apply(errorLogs, _toConsumableArray(logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5)));\n        }\n        // This catches the comparedValues where the following is logged\n        // <AnchorError>\n        // Left: <value>\n        // Right: <value>\n        else if (logs[anchorErrorLogIndex + 1].startsWith(\"Program log: Left:\")) {\n          var valueRegex = /^Program log: (Left|Right): (.*)$/;\n          var leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];\n          var rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];\n          errorLogs.push.apply(errorLogs, _toConsumableArray(logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3)));\n          comparedValues = [leftValue, rightValue];\n        }\n      }\n      var regexNoInfo = /^Program log: AnchorError occurred\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n      var noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);\n      var regexFileLine = /^Program log: AnchorError thrown in (.*):(\\d*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n      var fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);\n      var regexAccountName = /^Program log: AnchorError caused by account: (.*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n      var accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);\n      if (noInfoAnchorErrorLog) {\n        var _noInfoAnchorErrorLog = noInfoAnchorErrorLog.slice(1, 4),\n          _noInfoAnchorErrorLog2 = _slicedToArray(_noInfoAnchorErrorLog, 3),\n          errorCodeString = _noInfoAnchorErrorLog2[0],\n          errorNumber = _noInfoAnchorErrorLog2[1],\n          errorMessage = _noInfoAnchorErrorLog2[2];\n        var errorCode = {\n          code: errorCodeString,\n          number: parseInt(errorNumber)\n        };\n        return new AnchorError(errorCode, errorMessage, errorLogs, logs, undefined, comparedValues);\n      } else if (fileLineAnchorErrorLog) {\n        var _fileLineAnchorErrorL = fileLineAnchorErrorLog.slice(1, 6),\n          _fileLineAnchorErrorL2 = _slicedToArray(_fileLineAnchorErrorL, 5),\n          file = _fileLineAnchorErrorL2[0],\n          line = _fileLineAnchorErrorL2[1],\n          _errorCodeString = _fileLineAnchorErrorL2[2],\n          _errorNumber = _fileLineAnchorErrorL2[3],\n          _errorMessage = _fileLineAnchorErrorL2[4];\n        var _errorCode = {\n          code: _errorCodeString,\n          number: parseInt(_errorNumber)\n        };\n        var fileLine = {\n          file: file,\n          line: parseInt(line)\n        };\n        return new AnchorError(_errorCode, _errorMessage, errorLogs, logs, fileLine, comparedValues);\n      } else if (accountNameAnchorErrorLog) {\n        var _accountNameAnchorErr = accountNameAnchorErrorLog.slice(1, 5),\n          _accountNameAnchorErr2 = _slicedToArray(_accountNameAnchorErr, 4),\n          accountName = _accountNameAnchorErr2[0],\n          _errorCodeString2 = _accountNameAnchorErr2[1],\n          _errorNumber2 = _accountNameAnchorErr2[2],\n          _errorMessage2 = _accountNameAnchorErr2[3];\n        var origin = accountName;\n        var _errorCode2 = {\n          code: _errorCodeString2,\n          number: parseInt(_errorNumber2)\n        };\n        return new AnchorError(_errorCode2, _errorMessage2, errorLogs, logs, origin, comparedValues);\n      } else {\n        return null;\n      }\n    }\n  }]);\n  return AnchorError;\n}(_wrapNativeSuper(Error)); // An error from a user defined program.\nvar ProgramError = /*#__PURE__*/function (_Error5) {\n  _inherits(ProgramError, _Error5);\n  function ProgramError(code, msg, logs) {\n    var _this7;\n    _classCallCheck(this, ProgramError);\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(ProgramError).call(this));\n    _this7.code = code;\n    _this7.msg = msg;\n    _this7.logs = logs;\n    if (logs) {\n      _this7._programErrorStack = ProgramErrorStack.parse(logs);\n    }\n    return _this7;\n  }\n  _createClass(ProgramError, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.msg;\n    }\n  }, {\n    key: \"program\",\n    get: function get() {\n      var _a;\n      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack[this._programErrorStack.stack.length - 1];\n    }\n  }, {\n    key: \"programErrorStack\",\n    get: function get() {\n      var _a;\n      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(err, idlErrors) {\n      var errString = err.toString();\n      // TODO: don't rely on the error string. web3.js should preserve the error\n      //       code information instead of giving us an untyped string.\n      var unparsedErrorCode;\n      if (errString.includes(\"custom program error:\")) {\n        var components = errString.split(\"custom program error: \");\n        if (components.length !== 2) {\n          return null;\n        } else {\n          unparsedErrorCode = components[1];\n        }\n      } else {\n        var matches = errString.match(/\"Custom\":([0-9]+)}/g);\n        if (!matches || matches.length > 1) {\n          return null;\n        }\n        unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];\n      }\n      var errorCode;\n      try {\n        errorCode = parseInt(unparsedErrorCode);\n      } catch (parseErr) {\n        return null;\n      }\n      // Parse user error.\n      var errorMsg = idlErrors.get(errorCode);\n      if (errorMsg !== undefined) {\n        return new ProgramError(errorCode, errorMsg, err.logs);\n      }\n      // Parse framework internal error.\n      errorMsg = LangErrorMessage.get(errorCode);\n      if (errorMsg !== undefined) {\n        return new ProgramError(errorCode, errorMsg, err.logs);\n      }\n      // Unable to parse the error. Just return the untranslated error.\n      return null;\n    }\n  }]);\n  return ProgramError;\n}(_wrapNativeSuper(Error));\nfunction translateError(err, idlErrors) {\n  if (isSet(\"debug-logs\")) {\n    console.log(\"Translating error:\", err);\n  }\n  var anchorError = AnchorError.parse(err.logs);\n  if (anchorError) {\n    return anchorError;\n  }\n  var programError = ProgramError.parse(err, idlErrors);\n  if (programError) {\n    return programError;\n  }\n  if (err.logs) {\n    var handler = {\n      get: function get(target, prop) {\n        if (prop === \"programErrorStack\") {\n          return target.programErrorStack.stack;\n        } else if (prop === \"program\") {\n          return target.programErrorStack.stack[err.programErrorStack.stack.length - 1];\n        } else {\n          // this is the normal way to return all other props\n          // without modifying them.\n          // @ts-expect-error\n          return Reflect.get.apply(Reflect, arguments);\n        }\n      }\n    };\n    err.programErrorStack = ProgramErrorStack.parse(err.logs);\n    return new Proxy(err, handler);\n  }\n  return err;\n}\nvar LangErrorCode = {\n  // Instructions.\n  InstructionMissing: 100,\n  InstructionFallbackNotFound: 101,\n  InstructionDidNotDeserialize: 102,\n  InstructionDidNotSerialize: 103,\n  // IDL instructions.\n  IdlInstructionStub: 1000,\n  IdlInstructionInvalidProgram: 1001,\n  // Constraints.\n  ConstraintMut: 2000,\n  ConstraintHasOne: 2001,\n  ConstraintSigner: 2002,\n  ConstraintRaw: 2003,\n  ConstraintOwner: 2004,\n  ConstraintRentExempt: 2005,\n  ConstraintSeeds: 2006,\n  ConstraintExecutable: 2007,\n  ConstraintState: 2008,\n  ConstraintAssociated: 2009,\n  ConstraintAssociatedInit: 2010,\n  ConstraintClose: 2011,\n  ConstraintAddress: 2012,\n  ConstraintZero: 2013,\n  ConstraintTokenMint: 2014,\n  ConstraintTokenOwner: 2015,\n  ConstraintMintMintAuthority: 2016,\n  ConstraintMintFreezeAuthority: 2017,\n  ConstraintMintDecimals: 2018,\n  ConstraintSpace: 2019,\n  ConstraintAccountIsNone: 2020,\n  // Require.\n  RequireViolated: 2500,\n  RequireEqViolated: 2501,\n  RequireKeysEqViolated: 2502,\n  RequireNeqViolated: 2503,\n  RequireKeysNeqViolated: 2504,\n  RequireGtViolated: 2505,\n  RequireGteViolated: 2506,\n  // Accounts.\n  AccountDiscriminatorAlreadySet: 3000,\n  AccountDiscriminatorNotFound: 3001,\n  AccountDiscriminatorMismatch: 3002,\n  AccountDidNotDeserialize: 3003,\n  AccountDidNotSerialize: 3004,\n  AccountNotEnoughKeys: 3005,\n  AccountNotMutable: 3006,\n  AccountOwnedByWrongProgram: 3007,\n  InvalidProgramId: 3008,\n  InvalidProgramExecutable: 3009,\n  AccountNotSigner: 3010,\n  AccountNotSystemOwned: 3011,\n  AccountNotInitialized: 3012,\n  AccountNotProgramData: 3013,\n  AccountNotAssociatedTokenAccount: 3014,\n  AccountSysvarMismatch: 3015,\n  AccountReallocExceedsLimit: 3016,\n  AccountDuplicateReallocs: 3017,\n  // State.\n  StateInvalidAddress: 4000,\n  // Miscellaneous\n  DeclaredProgramIdMismatch: 4100,\n  // Used for APIs that shouldn't be used anymore.\n  Deprecated: 5000\n};\nvar LangErrorMessage = new Map([\n// Instructions.\n[LangErrorCode.InstructionMissing, \"8 byte instruction identifier not provided\"], [LangErrorCode.InstructionFallbackNotFound, \"Fallback functions are not supported\"], [LangErrorCode.InstructionDidNotDeserialize, \"The program could not deserialize the given instruction\"], [LangErrorCode.InstructionDidNotSerialize, \"The program could not serialize the given instruction\"],\n// Idl instructions.\n[LangErrorCode.IdlInstructionStub, \"The program was compiled without idl instructions\"], [LangErrorCode.IdlInstructionInvalidProgram, \"The transaction was given an invalid program for the IDL instruction\"],\n// Constraints.\n[LangErrorCode.ConstraintMut, \"A mut constraint was violated\"], [LangErrorCode.ConstraintHasOne, \"A has one constraint was violated\"], [LangErrorCode.ConstraintSigner, \"A signer constraint was violated\"], [LangErrorCode.ConstraintRaw, \"A raw constraint was violated\"], [LangErrorCode.ConstraintOwner, \"An owner constraint was violated\"], [LangErrorCode.ConstraintRentExempt, \"A rent exemption constraint was violated\"], [LangErrorCode.ConstraintSeeds, \"A seeds constraint was violated\"], [LangErrorCode.ConstraintExecutable, \"An executable constraint was violated\"], [LangErrorCode.ConstraintState, \"A state constraint was violated\"], [LangErrorCode.ConstraintAssociated, \"An associated constraint was violated\"], [LangErrorCode.ConstraintAssociatedInit, \"An associated init constraint was violated\"], [LangErrorCode.ConstraintClose, \"A close constraint was violated\"], [LangErrorCode.ConstraintAddress, \"An address constraint was violated\"], [LangErrorCode.ConstraintZero, \"Expected zero account discriminant\"], [LangErrorCode.ConstraintTokenMint, \"A token mint constraint was violated\"], [LangErrorCode.ConstraintTokenOwner, \"A token owner constraint was violated\"], [LangErrorCode.ConstraintMintMintAuthority, \"A mint mint authority constraint was violated\"], [LangErrorCode.ConstraintMintFreezeAuthority, \"A mint freeze authority constraint was violated\"], [LangErrorCode.ConstraintMintDecimals, \"A mint decimals constraint was violated\"], [LangErrorCode.ConstraintSpace, \"A space constraint was violated\"], [LangErrorCode.ConstraintAccountIsNone, \"A required account for the constraint is None\"],\n// Require.\n[LangErrorCode.RequireViolated, \"A require expression was violated\"], [LangErrorCode.RequireEqViolated, \"A require_eq expression was violated\"], [LangErrorCode.RequireKeysEqViolated, \"A require_keys_eq expression was violated\"], [LangErrorCode.RequireNeqViolated, \"A require_neq expression was violated\"], [LangErrorCode.RequireKeysNeqViolated, \"A require_keys_neq expression was violated\"], [LangErrorCode.RequireGtViolated, \"A require_gt expression was violated\"], [LangErrorCode.RequireGteViolated, \"A require_gte expression was violated\"],\n// Accounts.\n[LangErrorCode.AccountDiscriminatorAlreadySet, \"The account discriminator was already set on this account\"], [LangErrorCode.AccountDiscriminatorNotFound, \"No 8 byte discriminator was found on the account\"], [LangErrorCode.AccountDiscriminatorMismatch, \"8 byte discriminator did not match what was expected\"], [LangErrorCode.AccountDidNotDeserialize, \"Failed to deserialize the account\"], [LangErrorCode.AccountDidNotSerialize, \"Failed to serialize the account\"], [LangErrorCode.AccountNotEnoughKeys, \"Not enough account keys given to the instruction\"], [LangErrorCode.AccountNotMutable, \"The given account is not mutable\"], [LangErrorCode.AccountOwnedByWrongProgram, \"The given account is owned by a different program than expected\"], [LangErrorCode.InvalidProgramId, \"Program ID was not as expected\"], [LangErrorCode.InvalidProgramExecutable, \"Program account is not executable\"], [LangErrorCode.AccountNotSigner, \"The given account did not sign\"], [LangErrorCode.AccountNotSystemOwned, \"The given account is not owned by the system program\"], [LangErrorCode.AccountNotInitialized, \"The program expected this account to be already initialized\"], [LangErrorCode.AccountNotProgramData, \"The given account is not a program data account\"], [LangErrorCode.AccountNotAssociatedTokenAccount, \"The given account is not the associated token account\"], [LangErrorCode.AccountSysvarMismatch, \"The given public key does not match the required sysvar\"], [LangErrorCode.AccountReallocExceedsLimit, \"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit\"], [LangErrorCode.AccountDuplicateReallocs, \"The account was duplicated for more than one reallocation\"],\n// State.\n[LangErrorCode.StateInvalidAddress, \"The given state account does not have the correct address\"],\n// Miscellaneous\n[LangErrorCode.DeclaredProgramIdMismatch, \"The declared program id does not match the actual program id\"],\n// Deprecated\n[LangErrorCode.Deprecated, \"The API being used is deprecated and should no longer be used\"]]);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign$ = function __assign$1() {\n  _assign$ = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign$.apply(this, arguments);\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\n\n/**\n * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n */\n/**\n * Lower case as a function.\n */\nfunction lowerCase(str) {\n  return str.toLowerCase();\n}\n\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nvar DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];\n// Remove all non-word characters.\nvar DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;\n/**\n * Normalize the string into something other libraries can manipulate easier.\n */\nfunction noCase(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.splitRegexp,\n    splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a,\n    _b = options.stripRegexp,\n    stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b,\n    _c = options.transform,\n    transform = _c === void 0 ? lowerCase : _c,\n    _d = options.delimiter,\n    delimiter = _d === void 0 ? \" \" : _d;\n  var result = replace(replace(input, splitRegexp, \"$1\\0$2\"), stripRegexp, \"\\0\");\n  var start = 0;\n  var end = result.length;\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === \"\\0\") start++;\n  while (result.charAt(end - 1) === \"\\0\") end--;\n  // Transform each token independently.\n  return result.slice(start, end).split(\"\\0\").map(transform).join(delimiter);\n}\n/**\n * Replace `re` in the input string with the replacement value.\n */\nfunction replace(input, re, value) {\n  if (re instanceof RegExp) return input.replace(re, value);\n  return re.reduce(function (input, re) {\n    return input.replace(re, value);\n  }, input);\n}\nfunction dotCase(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return noCase(input, _assign({\n    delimiter: \".\"\n  }, options));\n}\nfunction snakeCase(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return dotCase(input, _assign$({\n    delimiter: \"_\"\n  }, options));\n}\nvar IdlCoder = /*#__PURE__*/function () {\n  function IdlCoder() {\n    _classCallCheck(this, IdlCoder);\n  }\n  _createClass(IdlCoder, null, [{\n    key: \"fieldLayout\",\n    value: function fieldLayout(field, types) {\n      var fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n      switch (field.type) {\n        case \"bool\":\n          {\n            return borsh.bool(fieldName);\n          }\n        case \"u8\":\n          {\n            return borsh.u8(fieldName);\n          }\n        case \"i8\":\n          {\n            return borsh.i8(fieldName);\n          }\n        case \"u16\":\n          {\n            return borsh.u16(fieldName);\n          }\n        case \"i16\":\n          {\n            return borsh.i16(fieldName);\n          }\n        case \"u32\":\n          {\n            return borsh.u32(fieldName);\n          }\n        case \"i32\":\n          {\n            return borsh.i32(fieldName);\n          }\n        case \"f32\":\n          {\n            return borsh.f32(fieldName);\n          }\n        case \"u64\":\n          {\n            return borsh.u64(fieldName);\n          }\n        case \"i64\":\n          {\n            return borsh.i64(fieldName);\n          }\n        case \"f64\":\n          {\n            return borsh.f64(fieldName);\n          }\n        case \"u128\":\n          {\n            return borsh.u128(fieldName);\n          }\n        case \"i128\":\n          {\n            return borsh.i128(fieldName);\n          }\n        case \"u256\":\n          {\n            return borsh.u256(fieldName);\n          }\n        case \"i256\":\n          {\n            return borsh.i256(fieldName);\n          }\n        case \"bytes\":\n          {\n            return borsh.vecU8(fieldName);\n          }\n        case \"string\":\n          {\n            return borsh.str(fieldName);\n          }\n        case \"publicKey\":\n          {\n            return borsh.publicKey(fieldName);\n          }\n        default:\n          {\n            if (\"vec\" in field.type) {\n              return borsh.vec(IdlCoder.fieldLayout({\n                name: undefined,\n                type: field.type.vec\n              }, types), fieldName);\n            } else if (\"option\" in field.type) {\n              return borsh.option(IdlCoder.fieldLayout({\n                name: undefined,\n                type: field.type.option\n              }, types), fieldName);\n            } else if (\"defined\" in field.type) {\n              var defined = field.type.defined;\n              // User defined type.\n              if (types === undefined) {\n                throw new IdlError(\"User defined types not provided\");\n              }\n              var filtered = types.filter(function (t) {\n                return t.name === defined;\n              });\n              if (filtered.length !== 1) {\n                throw new IdlError(\"Type not found: \".concat(JSON.stringify(field)));\n              }\n              return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n            } else if (\"array\" in field.type) {\n              var arrayTy = field.type.array[0];\n              var arrayLen = field.type.array[1];\n              var innerLayout = IdlCoder.fieldLayout({\n                name: undefined,\n                type: arrayTy\n              }, types);\n              return borsh.array(innerLayout, arrayLen, fieldName);\n            } else {\n              throw new Error(\"Not yet implemented: \".concat(field));\n            }\n          }\n      }\n    }\n  }, {\n    key: \"typeDefLayout\",\n    value: function typeDefLayout(typeDef) {\n      var types = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var name = arguments.length > 2 ? arguments[2] : undefined;\n      if (typeDef.type.kind === \"struct\") {\n        var fieldLayouts = typeDef.type.fields.map(function (field) {\n          var x = IdlCoder.fieldLayout(field, types);\n          return x;\n        });\n        return borsh.struct(fieldLayouts, name);\n      } else if (typeDef.type.kind === \"enum\") {\n        var variants = typeDef.type.variants.map(function (variant) {\n          var name = camelCase(variant.name);\n          if (variant.fields === undefined) {\n            return borsh.struct([], name);\n          }\n          var fieldLayouts = variant.fields.map(function (f, i) {\n            if (!f.hasOwnProperty(\"name\")) {\n              return IdlCoder.fieldLayout({\n                type: f,\n                name: i.toString()\n              }, types);\n            }\n            // this typescript conversion is ok\n            // because if f were of type IdlType\n            // (that does not have a name property)\n            // the check before would've errored\n            return IdlCoder.fieldLayout(f, types);\n          });\n          return borsh.struct(fieldLayouts, name);\n        });\n        if (name !== undefined) {\n          // Buffer-layout lib requires the name to be null (on construction)\n          // when used as a field.\n          return borsh.rustEnum(variants).replicate(name);\n        }\n        return borsh.rustEnum(variants, name);\n      } else {\n        throw new Error(\"Unknown type kint: \".concat(typeDef));\n      }\n    }\n  }]);\n  return IdlCoder;\n}();\n/**\n * Namespace for state method function signatures.\n */\nvar SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nvar SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nvar BorshInstructionCoder = /*#__PURE__*/function () {\n  function BorshInstructionCoder(idl) {\n    var _this8 = this;\n    _classCallCheck(this, BorshInstructionCoder);\n    this.idl = idl;\n    this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);\n    var sighashLayouts = new Map();\n    idl.instructions.forEach(function (ix) {\n      var sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58$1.encode(sh), {\n        layout: _this8.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n    if (idl.state) {\n      idl.state.methods.map(function (ix) {\n        var sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58$1.encode(sh), {\n          layout: _this8.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n  _createClass(BorshInstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = Buffer$1.alloc(1000); // TODO: use a tighter buffer.\n      var methodName = camelCase(ixName);\n      var layout = this.ixLayout.get(methodName);\n      if (!layout) {\n        throw new Error(\"Unknown method: \".concat(methodName));\n      }\n      var len = layout.encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return Buffer$1.concat([sighash(nameSpace, ixName), data]);\n    }\n  }, {\n    key: \"decode\",\n    /**\n     * Decodes a program instruction.\n     */\n    value: function decode(ix) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n      if (typeof ix === \"string\") {\n        ix = encoding === \"hex\" ? Buffer$1.from(ix, \"hex\") : bs58$1.decode(ix);\n      }\n      var sighash = bs58$1.encode(ix.slice(0, 8));\n      var data = ix.slice(8);\n      var decoder = this.sighashLayouts.get(sighash);\n      if (!decoder) {\n        return null;\n      }\n      return {\n        data: decoder.layout.decode(data),\n        name: decoder.name\n      };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n  }, {\n    key: \"format\",\n    value: function format(ix, accountMetas) {\n      return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          var _a, _b;\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          var _a, _b;\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }));\n      return new Map(ixLayouts);\n    }\n  }]);\n  return BorshInstructionCoder;\n}();\nvar InstructionFormatter = /*#__PURE__*/function () {\n  function InstructionFormatter() {\n    _classCallCheck(this, InstructionFormatter);\n  }\n  _createClass(InstructionFormatter, null, [{\n    key: \"format\",\n    value: function format(ix, accountMetas, idl) {\n      var idlIx = idl.instructions.filter(function (i) {\n        return ix.name === i.name;\n      })[0];\n      if (idlIx === undefined) {\n        console.error(\"Invalid instruction given\");\n        return null;\n      }\n      var args = idlIx.args.map(function (idlField) {\n        return {\n          name: idlField.name,\n          type: InstructionFormatter.formatIdlType(idlField.type),\n          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n        };\n      });\n      var flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n      var accounts = accountMetas.map(function (meta, idx) {\n        if (idx < flatIdlAccounts.length) {\n          return _objectSpread({\n            name: flatIdlAccounts[idx].name\n          }, meta);\n        }\n        // \"Remaining accounts\" are unnamed in Anchor.\n        else {\n          return _objectSpread({\n            name: undefined\n          }, meta);\n        }\n      });\n      return {\n        args: args,\n        accounts: accounts\n      };\n    }\n  }, {\n    key: \"formatIdlType\",\n    value: function formatIdlType(idlType) {\n      if (typeof idlType === \"string\") {\n        return idlType;\n      }\n      if (\"vec\" in idlType) {\n        return \"Vec<\".concat(this.formatIdlType(idlType.vec), \">\");\n      }\n      if (\"option\" in idlType) {\n        return \"Option<\".concat(this.formatIdlType(idlType.option), \">\");\n      }\n      if (\"defined\" in idlType) {\n        return idlType.defined;\n      }\n      if (\"array\" in idlType) {\n        return \"Array<\".concat(idlType.array[0], \"; \").concat(idlType.array[1], \">\");\n      }\n      throw new Error(\"Unknown IDL type: \".concat(idlType));\n    }\n  }, {\n    key: \"formatIdlData\",\n    value: function formatIdlData(idlField, data, types) {\n      var _this9 = this;\n      if (typeof idlField.type === \"string\") {\n        return data.toString();\n      }\n      if (idlField.type.hasOwnProperty(\"vec\")) {\n        return \"[\" + data.map(function (d) {\n          return _this9.formatIdlData({\n            name: \"\",\n            type: idlField.type.vec\n          }, d);\n        }).join(\", \") + \"]\";\n      }\n      if (idlField.type.hasOwnProperty(\"option\")) {\n        return data === null ? \"null\" : this.formatIdlData({\n          name: \"\",\n          type: idlField.type.option\n        }, data, types);\n      }\n      if (idlField.type.hasOwnProperty(\"defined\")) {\n        if (types === undefined) {\n          throw new Error(\"User defined types not provided\");\n        }\n        var filtered = types.filter(function (t) {\n          return t.name === idlField.type.defined;\n        });\n        if (filtered.length !== 1) {\n          throw new Error(\"Type not found: \".concat(idlField.type.defined));\n        }\n        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n      }\n      return \"unknown\";\n    }\n  }, {\n    key: \"formatIdlDataDefined\",\n    value: function formatIdlDataDefined(typeDef, data, types) {\n      if (typeDef.type.kind === \"struct\") {\n        var _struct = typeDef.type;\n        var fields = Object.keys(data).map(function (k) {\n          var f = _struct.fields.filter(function (f) {\n            return f.name === k;\n          })[0];\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n          return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n        }).join(\", \");\n        return \"{ \" + fields + \" }\";\n      } else {\n        if (typeDef.type.variants.length === 0) {\n          return \"{}\";\n        }\n        // Struct enum.\n        if (typeDef.type.variants[0].name) {\n          var variants = typeDef.type.variants;\n          var variant = Object.keys(data)[0];\n          var enumType = data[variant];\n          var namedFields = Object.keys(enumType).map(function (f) {\n            var _a;\n            var fieldData = enumType[f];\n            var idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(function (v) {\n              return v.name === f;\n            })[0];\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n          }).join(\", \");\n          var variantName = camelCase(variant, {\n            pascalCase: true\n          });\n          if (namedFields.length === 0) {\n            return variantName;\n          }\n          return \"\".concat(variantName, \" { \").concat(namedFields, \" }\");\n        }\n        // Tuple enum.\n        else {\n          // TODO.\n          return \"Tuple formatting not yet implemented\";\n        }\n      }\n    }\n  }, {\n    key: \"flattenIdlAccounts\",\n    value: function flattenIdlAccounts(accounts, prefix) {\n      return accounts.map(function (account) {\n        var accName = sentenceCase(account.name);\n        if (account.hasOwnProperty(\"accounts\")) {\n          var newPrefix = prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName;\n          return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);\n        } else {\n          return _objectSpread({}, account, {\n            name: prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName\n          });\n        }\n      }).flat();\n    }\n  }]);\n  return InstructionFormatter;\n}();\nfunction sentenceCase(field) {\n  var result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace, ixName) {\n  var name = snakeCase(ixName);\n  var preimage = \"\".concat(nameSpace, \":\").concat(name);\n  return Buffer$1.from(sha256$1.digest(preimage)).slice(0, 8);\n}\nfunction accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    var variantSizes = idlAccount.type.variants.map(function (variant) {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n      return variant.fields.map(function (f) {\n        if (!(typeof f === \"object\" && \"name\" in f)) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        }\n        return typeSize(idl, f.type);\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n    });\n    return Math.max.apply(Math, _toConsumableArray(variantSizes)) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields.map(function (f) {\n    return typeSize(idl, f.type);\n  }).reduce(function (a, b) {\n    return a + b;\n  }, 0);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n  var _a, _b;\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"i16\":\n      return 2;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"i32\":\n      return 4;\n    case \"f32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"f64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"u256\":\n      return 32;\n    case \"i256\":\n      return 32;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      if (\"vec\" in ty) {\n        return 1;\n      }\n      if (\"option\" in ty) {\n        return 1 + typeSize(idl, ty.option);\n      }\n      if (\"coption\" in ty) {\n        return 4 + typeSize(idl, ty.coption);\n      }\n      if (\"defined\" in ty) {\n        var filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter(function (t) {\n          return t.name === ty.defined;\n        })) !== null && _b !== void 0 ? _b : [];\n        if (filtered.length !== 1) {\n          throw new IdlError(\"Type not found: \".concat(JSON.stringify(ty)));\n        }\n        var typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      }\n      if (\"array\" in ty) {\n        var arrayTy = ty.array[0];\n        var arraySize = ty.array[1];\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(\"Invalid type \".concat(JSON.stringify(ty)));\n  }\n}\n\n/**\n * Number of bytes of the account discriminator.\n */\nvar ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Encodes and decodes account objects.\n */\nvar BorshAccountsCoder = /*#__PURE__*/function () {\n  function BorshAccountsCoder(idl) {\n    _classCallCheck(this, BorshAccountsCoder);\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    var layouts = idl.accounts.map(function (acc) {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n    this.accountLayouts = new Map(layouts);\n    this.idl = idl;\n  }\n  _createClass(BorshAccountsCoder, [{\n    key: \"encode\",\n    value: function () {\n      var _encode2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(accountName, account) {\n        var buffer, layout, len, accountData, discriminator;\n        return _regeneratorRuntime().wrap(function _callee6$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              buffer = Buffer$1.alloc(1000); // TODO: use a tighter buffer.\n              layout = this.accountLayouts.get(accountName);\n              if (layout) {\n                _context10.next = 4;\n                break;\n              }\n              throw new Error(\"Unknown account: \".concat(accountName));\n            case 4:\n              len = layout.encode(account, buffer);\n              accountData = buffer.slice(0, len);\n              discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n              return _context10.abrupt(\"return\", Buffer$1.concat([discriminator, accountData]));\n            case 8:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee6, this);\n      }));\n      function encode(_x31, _x32) {\n        return _encode2.apply(this, arguments);\n      }\n      return encode;\n    }()\n  }, {\n    key: \"decode\",\n    value: function decode(accountName, data) {\n      // Assert the account discriminator is correct.\n      var discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n      if (discriminator.compare(data.slice(0, 8))) {\n        throw new Error(\"Invalid account discriminator\");\n      }\n      return this.decodeUnchecked(accountName, data);\n    }\n  }, {\n    key: \"decodeAny\",\n    value: function decodeAny(data) {\n      var accountDescriminator = data.slice(0, 8);\n      var accountName = Array.from(this.accountLayouts.keys()).find(function (key) {\n        return BorshAccountsCoder.accountDiscriminator(key).equals(accountDescriminator);\n      });\n      if (!accountName) {\n        throw new Error(\"Account descriminator not found\");\n      }\n      return this.decodeUnchecked(accountName, data);\n    }\n  }, {\n    key: \"decodeUnchecked\",\n    value: function decodeUnchecked(accountName, ix) {\n      // Chop off the discriminator before decoding.\n      var data = ix.slice(ACCOUNT_DISCRIMINATOR_SIZE);\n      var layout = this.accountLayouts.get(accountName);\n      if (!layout) {\n        throw new Error(\"Unknown account: \".concat(accountName));\n      }\n      return layout.decode(data);\n    }\n  }, {\n    key: \"memcmp\",\n    value: function memcmp(accountName, appendData) {\n      var discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n      return {\n        offset: 0,\n        bytes: bs58$1.encode(appendData ? Buffer$1.concat([discriminator, appendData]) : discriminator)\n      };\n    }\n  }, {\n    key: \"size\",\n    value: function size(idlAccount) {\n      var _a;\n      return ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n     * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.\n     *\n     * @param name The name of the account to calculate the discriminator.\n     */\n  }], [{\n    key: \"accountDiscriminator\",\n    value: function accountDiscriminator(name) {\n      return Buffer$1.from(sha256$1.digest(\"account:\".concat(camelCase(name, {\n        pascalCase: true,\n        preserveConsecutiveUppercase: true\n      })))).slice(0, ACCOUNT_DISCRIMINATOR_SIZE);\n    }\n  }]);\n  return BorshAccountsCoder;\n}();\nvar BorshEventCoder = /*#__PURE__*/function () {\n  function BorshEventCoder(idl) {\n    _classCallCheck(this, BorshEventCoder);\n    if (idl.events === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n    var layouts = idl.events.map(function (event) {\n      var eventTypeDef = {\n        name: event.name,\n        type: {\n          kind: \"struct\",\n          fields: event.fields.map(function (f) {\n            return {\n              name: f.name,\n              type: f.type\n            };\n          })\n        }\n      };\n      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n    });\n    this.layouts = new Map(layouts);\n    this.discriminators = new Map(idl.events === undefined ? [] : idl.events.map(function (e) {\n      return [base64$1.fromByteArray(eventDiscriminator(e.name)), e.name];\n    }));\n  }\n  _createClass(BorshEventCoder, [{\n    key: \"decode\",\n    value: function decode(log) {\n      var logArr;\n      // This will throw if log length is not a multiple of 4.\n      try {\n        logArr = Buffer$1.from(base64$1.toByteArray(log));\n      } catch (e) {\n        return null;\n      }\n      var disc = base64$1.fromByteArray(logArr.slice(0, 8));\n      // Only deserialize if the discriminator implies a proper event.\n      var eventName = this.discriminators.get(disc);\n      if (eventName === undefined) {\n        return null;\n      }\n      var layout = this.layouts.get(eventName);\n      if (!layout) {\n        throw new Error(\"Unknown event: \".concat(eventName));\n      }\n      var data = layout.decode(logArr.slice(8));\n      return {\n        data: data,\n        name: eventName\n      };\n    }\n  }]);\n  return BorshEventCoder;\n}();\nfunction eventDiscriminator(name) {\n  return Buffer$1.from(sha256$1.digest(\"event:\".concat(name))).slice(0, 8);\n}\nvar BorshStateCoder = /*#__PURE__*/function () {\n  function BorshStateCoder(idl) {\n    _classCallCheck(this, BorshStateCoder);\n    if (idl.state === undefined) {\n      throw new Error(\"Idl state not defined.\");\n    }\n    this.layout = IdlCoder.typeDefLayout(idl.state.struct, idl.types);\n  }\n  _createClass(BorshStateCoder, [{\n    key: \"encode\",\n    value: function () {\n      var _encode3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(name, account) {\n        var buffer, len, disc, accData;\n        return _regeneratorRuntime().wrap(function _callee7$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              buffer = Buffer$1.alloc(1000); // TODO: use a tighter buffer.\n              len = this.layout.encode(account, buffer);\n              _context11.next = 4;\n              return stateDiscriminator(name);\n            case 4:\n              disc = _context11.sent;\n              accData = buffer.slice(0, len);\n              return _context11.abrupt(\"return\", Buffer$1.concat([disc, accData]));\n            case 7:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee7, this);\n      }));\n      function encode(_x33, _x34) {\n        return _encode3.apply(this, arguments);\n      }\n      return encode;\n    }()\n  }, {\n    key: \"decode\",\n    value: function decode(ix) {\n      // Chop off discriminator.\n      var data = ix.slice(8);\n      return this.layout.decode(data);\n    }\n  }]);\n  return BorshStateCoder;\n}(); // Calculates unique 8 byte discriminator prepended to all anchor state accounts.\nfunction stateDiscriminator(_x35) {\n  return _stateDiscriminator.apply(this, arguments);\n}\n/**\n * Encodes and decodes user-defined types.\n */\nfunction _stateDiscriminator() {\n  _stateDiscriminator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee60(name) {\n    var ns;\n    return _regeneratorRuntime().wrap(function _callee60$(_context65) {\n      while (1) switch (_context65.prev = _context65.next) {\n        case 0:\n          ns = isSet(\"anchor-deprecated-state\") ? \"account\" : \"state\";\n          return _context65.abrupt(\"return\", Buffer$1.from(sha256$1.digest(\"\".concat(ns, \":\").concat(name))).slice(0, 8));\n        case 2:\n        case \"end\":\n          return _context65.stop();\n      }\n    }, _callee60);\n  }));\n  return _stateDiscriminator.apply(this, arguments);\n}\nvar BorshTypesCoder = /*#__PURE__*/function () {\n  function BorshTypesCoder(idl) {\n    _classCallCheck(this, BorshTypesCoder);\n    if (idl.types === undefined) {\n      this.typeLayouts = new Map();\n      return;\n    }\n    var layouts = idl.types.map(function (acc) {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n    this.typeLayouts = new Map(layouts);\n    this.idl = idl;\n  }\n  _createClass(BorshTypesCoder, [{\n    key: \"encode\",\n    value: function encode(typeName, type) {\n      var buffer = Buffer$1.alloc(1000); // TODO: use a tighter buffer.\n      var layout = this.typeLayouts.get(typeName);\n      if (!layout) {\n        throw new Error(\"Unknown type: \".concat(typeName));\n      }\n      var len = layout.encode(type, buffer);\n      return buffer.slice(0, len);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(typeName, typeData) {\n      var layout = this.typeLayouts.get(typeName);\n      if (!layout) {\n        throw new Error(\"Unknown type: \".concat(typeName));\n      }\n      return layout.decode(typeData);\n    }\n  }]);\n  return BorshTypesCoder;\n}();\n/**\n * BorshCoder is the default Coder for Anchor programs implementing the\n * borsh based serialization interface.\n */\nvar BorshCoder = function BorshCoder(idl) {\n  _classCallCheck(this, BorshCoder);\n  this.instruction = new BorshInstructionCoder(idl);\n  this.accounts = new BorshAccountsCoder(idl);\n  this.events = new BorshEventCoder(idl);\n  if (idl.state) {\n    this.state = new BorshStateCoder(idl);\n  }\n  this.types = new BorshTypesCoder(idl);\n};\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nvar Layout = /*#__PURE__*/function () {\n  function Layout(span, property) {\n    _classCallCheck(this, Layout);\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  _createClass(Layout, [{\n    key: \"makeDestinationObject\",\n    value: function makeDestinationObject() {\n      return {};\n    }\n    /**\n     * Decode from a Buffer into an JavaScript value.\n     *\n     * @param {Buffer} b - the buffer from which encoded data is read.\n     *\n     * @param {Number} [offset] - the offset at which the encoded data\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @returns {(Number|Array|Object)} - the value of the decoded data.\n     *\n     * @abstract\n     */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      throw new Error('Layout is abstract');\n    }\n    /**\n     * Encode a JavaScript value into a Buffer.\n     *\n     * @param {(Number|Array|Object)} src - the value to be encoded into\n     * the buffer.  The type accepted depends on the (sub-)type of {@link\n     * Layout}.\n     *\n     * @param {Buffer} b - the buffer into which encoded data will be\n     * written.\n     *\n     * @param {Number} [offset] - the offset at which the encoded data\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @returns {Number} - the number of bytes encoded, including the\n     * space skipped for internal padding, but excluding data such as\n     * {@link Sequence#count|lengths} when stored {@link\n     * ExternalLayout|externally}.  This is the adjustment to `offset`\n     * producing the offset where data for the next layout would be\n     * written.\n     *\n     * @abstract\n     */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      throw new Error('Layout is abstract');\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Buffer} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 > this.span) {\n        throw new RangeError('indeterminate span');\n      }\n      return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */\n  }, {\n    key: \"replicate\",\n    value: function replicate(property) {\n      var rv = Object.create(this.constructor.prototype);\n      Object.assign(rv, this);\n      rv.property = property;\n      return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      return undefined;\n    }\n  }]);\n  return Layout;\n}();\nvar Layout_2 = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nvar ExternalLayout = /*#__PURE__*/function (_Layout) {\n  _inherits(ExternalLayout, _Layout);\n  function ExternalLayout() {\n    _classCallCheck(this, ExternalLayout);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ExternalLayout).apply(this, arguments));\n  }\n  _createClass(ExternalLayout, [{\n    key: \"isCount\",\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */\n    value: function isCount() {\n      throw new Error('ExternalLayout is abstract');\n    }\n  }]);\n  return ExternalLayout;\n}(Layout);\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nvar OffsetLayout = /*#__PURE__*/function (_ExternalLayout) {\n  _inherits(OffsetLayout, _ExternalLayout);\n  function OffsetLayout(layout, offset, property) {\n    var _this10;\n    _classCallCheck(this, OffsetLayout);\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(OffsetLayout).call(this, layout.span, property || layout.property));\n\n    /** The subordinated layout. */\n    _this10.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    _this10.offset = offset;\n    return _this10;\n  }\n\n  /** @override */\n  _createClass(OffsetLayout, [{\n    key: \"isCount\",\n    value: function isCount() {\n      return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    } /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return this.layout.decode(b, offset + this.offset);\n    } /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return this.layout.encode(src, b, offset + this.offset);\n    }\n  }]);\n  return OffsetLayout;\n}(ExternalLayout);\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar UInt = /*#__PURE__*/function (_Layout2) {\n  _inherits(UInt, _Layout2);\n  function UInt(span, property) {\n    var _this11;\n    _classCallCheck(this, UInt);\n    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(UInt).call(this, span, property));\n    if (6 < _this11.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n    return _this11;\n  }\n\n  /** @override */\n  _createClass(UInt, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readUIntLE(offset, this.span);\n    } /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeUIntLE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n  return UInt;\n}(Layout);\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar UIntBE = /*#__PURE__*/function (_Layout3) {\n  _inherits(UIntBE, _Layout3);\n  function UIntBE(span, property) {\n    var _this12;\n    _classCallCheck(this, UIntBE);\n    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(UIntBE).call(this, span, property));\n    if (6 < _this12.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n    return _this12;\n  }\n\n  /** @override */\n  _createClass(UIntBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readUIntBE(offset, this.span);\n    } /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeUIntBE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n  return UIntBE;\n}(Layout);\nvar V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  var hi32 = Math.floor(src / V2E32);\n  var lo32 = src - hi32 * V2E32;\n  return {\n    hi32: hi32,\n    lo32: lo32\n  };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nvar NearUInt64 = /*#__PURE__*/function (_Layout4) {\n  _inherits(NearUInt64, _Layout4);\n  function NearUInt64(property) {\n    _classCallCheck(this, NearUInt64);\n    return _possibleConstructorReturn(this, _getPrototypeOf(NearUInt64).call(this, 8, property));\n  }\n\n  /** @override */\n  _createClass(NearUInt64, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var lo32 = b.readUInt32LE(offset);\n      var hi32 = b.readUInt32LE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    } /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var split = divmodInt64(src);\n      b.writeUInt32LE(split.lo32, offset);\n      b.writeUInt32LE(split.hi32, offset + 4);\n      return 8;\n    }\n  }]);\n  return NearUInt64;\n}(Layout);\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nvar NearInt64 = /*#__PURE__*/function (_Layout5) {\n  _inherits(NearInt64, _Layout5);\n  function NearInt64(property) {\n    _classCallCheck(this, NearInt64);\n    return _possibleConstructorReturn(this, _getPrototypeOf(NearInt64).call(this, 8, property));\n  }\n\n  /** @override */\n  _createClass(NearInt64, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var lo32 = b.readUInt32LE(offset);\n      var hi32 = b.readInt32LE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    } /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var split = divmodInt64(src);\n      b.writeUInt32LE(split.lo32, offset);\n      b.writeInt32LE(split.hi32, offset + 4);\n      return 8;\n    }\n  }]);\n  return NearInt64;\n}(Layout);\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nvar Structure = /*#__PURE__*/function (_Layout6) {\n  _inherits(Structure, _Layout6);\n  function Structure(fields, property, decodePrefixes) {\n    var _this13;\n    _classCallCheck(this, Structure);\n    if (!(Array.isArray(fields) && fields.reduce(function (acc, v) {\n      return acc && v instanceof Layout;\n    }, true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if ('boolean' === typeof property && undefined === decodePrefixes) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    var _iterator10 = _createForOfIteratorHelper(fields),\n      _step10;\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var fd = _step10.value;\n        if (0 > fd.span && undefined === fd.property) {\n          throw new Error('fields cannot contain unnamed variable-length layout');\n        }\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n    var span = -1;\n    try {\n      span = fields.reduce(function (span, fd) {\n        return span + fd.getSpan();\n      }, 0);\n    } catch (e) {}\n    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(Structure).call(this, span, property));\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    _this13.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    _this13.decodePrefixes = !!decodePrefixes;\n    return _this13;\n  }\n\n  /** @override */\n  _createClass(Structure, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var span = 0;\n      try {\n        span = this.fields.reduce(function (span, fd) {\n          var fsp = fd.getSpan(b, offset);\n          offset += fsp;\n          return span + fsp;\n        }, 0);\n      } catch (e) {\n        throw new RangeError('indeterminate span');\n      }\n      return span;\n    } /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var dest = this.makeDestinationObject();\n      var _iterator11 = _createForOfIteratorHelper(this.fields),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var fd = _step11.value;\n          if (undefined !== fd.property) {\n            dest[fd.property] = fd.decode(b, offset);\n          }\n          offset += fd.getSpan(b, offset);\n          if (this.decodePrefixes && b.length === offset) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n      return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var firstOffset = offset;\n      var lastOffset = 0;\n      var lastWrote = 0;\n      var _iterator12 = _createForOfIteratorHelper(this.fields),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var fd = _step12.value;\n          var span = fd.span;\n          lastWrote = 0 < span ? span : 0;\n          if (undefined !== fd.property) {\n            var fv = src[fd.property];\n            if (undefined !== fv) {\n              lastWrote = fd.encode(fv, b, offset);\n              if (0 > span) {\n                /* Read the as-encoded span, which is not necessarily the\n                 * same as what we wrote. */\n                span = fd.getSpan(b, offset);\n              }\n            }\n          }\n          lastOffset = offset;\n          offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      return lastOffset + lastWrote - firstOffset;\n    } /** @override */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      var dest = this.makeDestinationObject();\n      var _iterator13 = _createForOfIteratorHelper(this.fields),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var fd = _step13.value;\n          if (undefined !== fd.property && 0 < values.length) {\n            dest[fd.property] = values.shift();\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */\n  }, {\n    key: \"layoutFor\",\n    value: function layoutFor(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n      var _iterator14 = _createForOfIteratorHelper(this.fields),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var fd = _step14.value;\n          if (fd.property === property) {\n            return fd;\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */\n  }, {\n    key: \"offsetOf\",\n    value: function offsetOf(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n      var offset = 0;\n      var _iterator15 = _createForOfIteratorHelper(this.fields),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var fd = _step15.value;\n          if (fd.property === property) {\n            return offset;\n          }\n          if (0 > fd.span) {\n            offset = -1;\n          } else if (0 <= offset) {\n            offset += fd.span;\n          }\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n  }]);\n  return Structure;\n}(Layout);\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nvar UnionDiscriminator = /*#__PURE__*/function () {\n  function UnionDiscriminator(property) {\n    _classCallCheck(this, UnionDiscriminator);\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  _createClass(UnionDiscriminator, [{\n    key: \"decode\",\n    value: function decode() {\n      throw new Error('UnionDiscriminator is abstract');\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      throw new Error('UnionDiscriminator is abstract');\n    }\n  }]);\n  return UnionDiscriminator;\n}();\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nvar UnionLayoutDiscriminator = /*#__PURE__*/function (_UnionDiscriminator) {\n  _inherits(UnionLayoutDiscriminator, _UnionDiscriminator);\n  function UnionLayoutDiscriminator(layout, property) {\n    var _this14;\n    _classCallCheck(this, UnionLayoutDiscriminator);\n    if (!(layout instanceof ExternalLayout && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n    _this14 = _possibleConstructorReturn(this, _getPrototypeOf(UnionLayoutDiscriminator).call(this, property || layout.property || 'variant'));\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    _this14.layout = layout;\n    return _this14;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  _createClass(UnionLayoutDiscriminator, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      return this.layout.decode(b, offset);\n    } /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      return this.layout.encode(src, b, offset);\n    }\n  }]);\n  return UnionLayoutDiscriminator;\n}(UnionDiscriminator);\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Union = /*#__PURE__*/function (_Layout7) {\n  _inherits(Union, _Layout7);\n  function Union(discr, defaultLayout, property) {\n    var _this15;\n    _classCallCheck(this, Union);\n    var upv = discr instanceof UInt || discr instanceof UIntBE;\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if (discr instanceof ExternalLayout && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    var span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if (0 <= span && upv) {\n        span += discr.layout.span;\n      }\n    }\n    _this15 = _possibleConstructorReturn(this, _getPrototypeOf(Union).call(this, span, property));\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    _this15.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    _this15.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    _this15.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    _this15.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    var boundGetSourceVariant = _this15.defaultGetSourceVariant.bind(_assertThisInitialized(_assertThisInitialized(_this15)));\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    _this15.getSourceVariant = function (src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    _this15.configGetSourceVariant = function (gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n    return _this15;\n  }\n\n  /** @override */\n  _createClass(Union, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      /* Default layouts always have non-negative span, so we don't have\n       * one and we have to recognize the variant which will in turn\n       * determine the span. */\n      var vlo = this.getVariant(b, offset);\n      if (!vlo) {\n        throw new Error('unable to determine span for unrecognized variant');\n      }\n      return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisified rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */\n  }, {\n    key: \"defaultGetSourceVariant\",\n    value: function defaultGetSourceVariant(src) {\n      if (src.hasOwnProperty(this.discriminator.property)) {\n        if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {\n          return undefined;\n        }\n        var vlo = this.registry[src[this.discriminator.property]];\n        if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {\n          return vlo;\n        }\n      } else {\n        for (var tag in this.registry) {\n          var _vlo = this.registry[tag];\n          if (src.hasOwnProperty(_vlo.property)) {\n            return _vlo;\n          }\n        }\n      }\n      throw new Error('unable to infer src variant');\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var dest;\n      var dlo = this.discriminator;\n      var discr = dlo.decode(b, offset);\n      var clo = this.registry[discr];\n      if (undefined === clo) {\n        var contentOffset = 0;\n        clo = this.defaultLayout;\n        if (this.usesPrefixDiscriminator) {\n          contentOffset = dlo.layout.span;\n        }\n        dest = this.makeDestinationObject();\n        dest[dlo.property] = discr;\n        dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n      } else {\n        dest = clo.decode(b, offset);\n      }\n      return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var vlo = this.getSourceVariant(src);\n      if (undefined === vlo) {\n        var dlo = this.discriminator;\n        var clo = this.defaultLayout;\n        var contentOffset = 0;\n        if (this.usesPrefixDiscriminator) {\n          contentOffset = dlo.layout.span;\n        }\n        dlo.encode(src[dlo.property], b, offset);\n        return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n      }\n      return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */\n  }, {\n    key: \"addVariant\",\n    value: function addVariant(variant, layout, property) {\n      var rv = new VariantLayout(this, variant, layout, property);\n      this.registry[variant] = rv;\n      return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Buffer)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Buffer}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */\n  }, {\n    key: \"getVariant\",\n    value: function getVariant(vb, offset) {\n      var variant = vb;\n      if (Buffer.isBuffer(vb)) {\n        if (undefined === offset) {\n          offset = 0;\n        }\n        variant = this.discriminator.decode(vb, offset);\n      }\n      return this.registry[variant];\n    }\n  }]);\n  return Union;\n}(Layout);\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nvar VariantLayout = /*#__PURE__*/function (_Layout8) {\n  _inherits(VariantLayout, _Layout8);\n  function VariantLayout(union, variant, layout, property) {\n    var _this16;\n    _classCallCheck(this, VariantLayout);\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if (!Number.isInteger(variant) || 0 > variant) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if ('string' === typeof layout && undefined === property) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    var span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if (0 <= span && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    _this16 = _possibleConstructorReturn(this, _getPrototypeOf(VariantLayout).call(this, span, property));\n\n    /** The {@link Union} to which this variant belongs. */\n    _this16.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    _this16.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    _this16.layout = layout || null;\n    return _this16;\n  }\n\n  /** @override */\n  _createClass(VariantLayout, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        /* Will be equal to the containing union span if that is not\n         * variable. */\n        return this.span;\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var contentOffset = 0;\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n      /* Span is defined solely by the variant (and prefix discriminator) */\n      return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n    } /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      var dest = this.makeDestinationObject();\n      if (undefined === offset) {\n        offset = 0;\n      }\n      if (this !== this.union.getVariant(b, offset)) {\n        throw new Error('variant mismatch');\n      }\n      var contentOffset = 0;\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n      if (this.layout) {\n        dest[this.property] = this.layout.decode(b, offset + contentOffset);\n      } else if (this.property) {\n        dest[this.property] = true;\n      } else if (this.union.usesPrefixDiscriminator) {\n        dest[this.union.discriminator.property] = this.variant;\n      }\n      return dest;\n    } /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var contentOffset = 0;\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n      if (this.layout && !src.hasOwnProperty(this.property)) {\n        throw new TypeError('variant lacks property ' + this.property);\n      }\n      this.union.discriminator.encode(this.variant, b, offset);\n      var span = contentOffset;\n      if (this.layout) {\n        this.layout.encode(src[this.property], b, offset + contentOffset);\n        span += this.layout.getSpan(b, offset + contentOffset);\n        if (0 <= this.union.span && span > this.union.span) {\n          throw new Error('encoded variant overruns containing union');\n        }\n      }\n      return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      if (this.layout) {\n        return this.layout.fromArray(values);\n      }\n    }\n  }]);\n  return VariantLayout;\n}(Layout);\n/* eslint-enable no-extend-native */\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Blob$1 = /*#__PURE__*/function (_Layout9) {\n  _inherits(Blob$1, _Layout9);\n  function Blob$1(length, property) {\n    var _this17;\n    _classCallCheck(this, Blob$1);\n    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n      throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');\n    }\n    var span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    _this17 = _possibleConstructorReturn(this, _getPrototypeOf(Blob$1).call(this, span, property));\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    _this17.length = length;\n    return _this17;\n  }\n\n  /** @override */\n  _createClass(Blob$1, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      var span = this.span;\n      if (0 > span) {\n        span = this.length.decode(b, offset);\n      }\n      return span;\n    } /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var span = this.span;\n      if (0 > span) {\n        span = this.length.decode(b, offset);\n      }\n      return b.slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      var span = this.length;\n      if (this.length instanceof ExternalLayout) {\n        span = src.length;\n      }\n      if (!(Buffer.isBuffer(src) && span === src.length)) {\n        throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Buffer as src');\n      }\n      if (offset + span > b.length) {\n        throw new RangeError('encoding overruns Buffer');\n      }\n      b.write(src.toString('hex'), offset, span, 'hex');\n      if (this.length instanceof ExternalLayout) {\n        this.length.encode(span, b, offset);\n      }\n      return span;\n    }\n  }]);\n  return Blob$1;\n}(Layout);\n/** Factory for {@link OffsetLayout}. */\nvar offset = function offset(layout, _offset, property) {\n  return new OffsetLayout(layout, _offset, property);\n};\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nvar u8 = function u8(property) {\n  return new UInt(1, property);\n};\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nvar u32 = function u32(property) {\n  return new UInt(4, property);\n};\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nvar nu64 = function nu64(property) {\n  return new NearUInt64(property);\n};\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nvar ns64 = function ns64(property) {\n  return new NearInt64(property);\n};\n\n/** Factory for {@link Structure} values. */\nvar struct = function struct(fields, property, decodePrefixes) {\n  return new Structure(fields, property, decodePrefixes);\n};\n\n/** Factory for {@link Union} values. */\nvar union = function union(discr, defaultLayout, property) {\n  return new Union(discr, defaultLayout, property);\n};\n\n/** Factory for {@link Blob} values. */\nvar blob = function blob(length, property) {\n  return new Blob$1(length, property);\n};\nvar SystemInstructionCoder = /*#__PURE__*/function () {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  function SystemInstructionCoder(_) {\n    _classCallCheck(this, SystemInstructionCoder);\n  }\n  _createClass(SystemInstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      switch (camelCase(ixName)) {\n        case \"createAccount\":\n          {\n            return encodeCreateAccount(ix);\n          }\n        case \"assign\":\n          {\n            return encodeAssign(ix);\n          }\n        case \"transfer\":\n          {\n            return encodeTransfer(ix);\n          }\n        case \"createAccountWithSeed\":\n          {\n            return encodeCreateAccountWithSeed(ix);\n          }\n        case \"advanceNonceAccount\":\n          {\n            return encodeAdvanceNonceAccount(ix);\n          }\n        case \"withdrawNonceAccount\":\n          {\n            return encodeWithdrawNonceAccount(ix);\n          }\n        case \"initializeNonceAccount\":\n          {\n            return encodeInitializeNonceAccount(ix);\n          }\n        case \"authorizeNonceAccount\":\n          {\n            return encodeAuthorizeNonceAccount(ix);\n          }\n        case \"allocate\":\n          {\n            return encodeAllocate(ix);\n          }\n        case \"allocateWithSeed\":\n          {\n            return encodeAllocateWithSeed(ix);\n          }\n        case \"assignWithSeed\":\n          {\n            return encodeAssignWithSeed(ix);\n          }\n        case \"transferWithSeed\":\n          {\n            return encodeTransferWithSeed(ix);\n          }\n        default:\n          {\n            throw new Error(\"Invalid instruction: \".concat(ixName));\n          }\n      }\n    }\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(_ixName, _ix) {\n      throw new Error(\"System does not have state\");\n    }\n  }]);\n  return SystemInstructionCoder;\n}();\nvar RustStringLayout = /*#__PURE__*/function (_Layout_) {\n  _inherits(RustStringLayout, _Layout_);\n  function RustStringLayout(property) {\n    var _this18;\n    _classCallCheck(this, RustStringLayout);\n    _this18 = _possibleConstructorReturn(this, _getPrototypeOf(RustStringLayout).call(this, -1, property));\n    _this18.property = property;\n    _this18.layout = struct([u32(\"length\"), u32(\"lengthPadding\"), blob(offset(u32(), -8), \"chars\")], _this18.property);\n    return _this18;\n  }\n  _createClass(RustStringLayout, [{\n    key: \"encode\",\n    value: function encode(src, b) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (src === null || src === undefined) {\n        return this.layout.span;\n      }\n      var data = {\n        chars: Buffer.from(src, \"utf8\")\n      };\n      return this.layout.encode(data, b, offset);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(b) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var data = this.layout.decode(b, offset);\n      return data[\"chars\"].toString();\n    }\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(b) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return u32().span + u32().span + new BN(new Uint8Array(b).slice(offset, offset + 4), 10, \"le\").toNumber();\n    }\n  }]);\n  return RustStringLayout;\n}(Layout_2);\nfunction rustStringLayout(property) {\n  return new RustStringLayout(property);\n}\nfunction publicKey$2(property) {\n  return blob(32, property);\n}\nfunction encodeCreateAccount(_ref) {\n  var lamports = _ref.lamports,\n    space = _ref.space,\n    owner = _ref.owner;\n  return encodeData({\n    createAccount: {\n      lamports: lamports,\n      space: space,\n      owner: owner.toBuffer()\n    }\n  });\n}\nfunction encodeAssign(_ref2) {\n  var owner = _ref2.owner;\n  return encodeData({\n    assign: {\n      owner: owner.toBuffer()\n    }\n  });\n}\nfunction encodeTransfer(_ref3) {\n  var lamports = _ref3.lamports;\n  return encodeData({\n    transfer: {\n      lamports: lamports\n    }\n  });\n}\nfunction encodeCreateAccountWithSeed(_ref4) {\n  var base = _ref4.base,\n    seed = _ref4.seed,\n    lamports = _ref4.lamports,\n    space = _ref4.space,\n    owner = _ref4.owner;\n  return encodeData({\n    createAccountWithSeed: {\n      base: base.toBuffer(),\n      seed: seed,\n      lamports: lamports,\n      space: space,\n      owner: owner.toBuffer()\n    }\n  }, LAYOUT.getVariant(3).span + seed.length);\n}\nfunction encodeInitializeNonceAccount(_ref5) {\n  var authorized = _ref5.authorized;\n  return encodeData({\n    initializeNonceAccount: {\n      authorized: authorized.toBuffer()\n    }\n  });\n}\nfunction encodeAdvanceNonceAccount(_ref6) {\n  var authorized = _ref6.authorized;\n  return encodeData({\n    advanceNonceAccount: {\n      authorized: authorized.toBuffer()\n    }\n  });\n}\nfunction encodeWithdrawNonceAccount(_ref7) {\n  var lamports = _ref7.lamports;\n  return encodeData({\n    withdrawNonceAccount: {\n      lamports: lamports\n    }\n  });\n}\nfunction encodeAuthorizeNonceAccount(_ref8) {\n  var authorized = _ref8.authorized;\n  return encodeData({\n    authorizeNonceAccount: {\n      authorized: authorized.toBuffer()\n    }\n  });\n}\nfunction encodeAllocate(_ref9) {\n  var space = _ref9.space;\n  return encodeData({\n    allocate: {\n      space: space\n    }\n  });\n}\nfunction encodeAllocateWithSeed(_ref10) {\n  var base = _ref10.base,\n    seed = _ref10.seed,\n    space = _ref10.space,\n    owner = _ref10.owner;\n  return encodeData({\n    allocateWithSeed: {\n      base: base.toBuffer(),\n      seed: seed,\n      space: space,\n      owner: owner.toBuffer()\n    }\n  }, LAYOUT.getVariant(9).span + seed.length);\n}\nfunction encodeAssignWithSeed(_ref11) {\n  var base = _ref11.base,\n    seed = _ref11.seed,\n    owner = _ref11.owner;\n  return encodeData({\n    assignWithSeed: {\n      base: base.toBuffer(),\n      seed: seed,\n      owner: owner.toBuffer()\n    }\n  }, LAYOUT.getVariant(10).span + seed.length);\n}\nfunction encodeTransferWithSeed(_ref12) {\n  var lamports = _ref12.lamports,\n    seed = _ref12.seed,\n    owner = _ref12.owner;\n  return encodeData({\n    transferWithSeed: {\n      lamports: lamports,\n      seed: seed,\n      owner: owner.toBuffer()\n    }\n  }, LAYOUT.getVariant(11).span + seed.length);\n}\nvar LAYOUT = union(u32(\"instruction\"));\nLAYOUT.addVariant(0, struct([ns64(\"lamports\"), ns64(\"space\"), publicKey$2(\"owner\")]), \"createAccount\");\nLAYOUT.addVariant(1, struct([publicKey$2(\"owner\")]), \"assign\");\nLAYOUT.addVariant(2, struct([ns64(\"lamports\")]), \"transfer\");\nLAYOUT.addVariant(3, struct([publicKey$2(\"base\"), rustStringLayout(\"seed\"), ns64(\"lamports\"), ns64(\"space\"), publicKey$2(\"owner\")]), \"createAccountWithSeed\");\nLAYOUT.addVariant(4, struct([publicKey$2(\"authorized\")]), \"advanceNonceAccount\");\nLAYOUT.addVariant(5, struct([ns64(\"lamports\")]), \"withdrawNonceAccount\");\nLAYOUT.addVariant(6, struct([publicKey$2(\"authorized\")]), \"initializeNonceAccount\");\nLAYOUT.addVariant(7, struct([publicKey$2(\"authorized\")]), \"authorizeNonceAccount\");\nLAYOUT.addVariant(8, struct([ns64(\"space\")]), \"allocate\");\nLAYOUT.addVariant(9, struct([publicKey$2(\"base\"), rustStringLayout(\"seed\"), ns64(\"space\"), publicKey$2(\"owner\")]), \"allocateWithSeed\");\nLAYOUT.addVariant(10, struct([publicKey$2(\"base\"), rustStringLayout(\"seed\"), publicKey$2(\"owner\")]), \"assignWithSeed\");\nLAYOUT.addVariant(11, struct([ns64(\"lamports\"), rustStringLayout(\"seed\"), publicKey$2(\"owner\")]), \"transferWithSeed\");\nfunction encodeData(instruction, maxSpan) {\n  var b = Buffer.alloc(maxSpan !== null && maxSpan !== void 0 ? maxSpan : instructionMaxSpan);\n  var span = LAYOUT.encode(instruction, b);\n  if (maxSpan === undefined) {\n    return b.slice(0, span);\n  }\n  return b;\n}\nvar instructionMaxSpan = Math.max.apply(Math, _toConsumableArray(Object.values(LAYOUT.registry).map(function (r) {\n  return r.span;\n})));\nvar SystemStateCoder = /*#__PURE__*/function () {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  function SystemStateCoder(_idl) {\n    _classCallCheck(this, SystemStateCoder);\n  }\n  _createClass(SystemStateCoder, [{\n    key: \"encode\",\n    value: function encode(_name, _account) {\n      throw new Error(\"System does not have state\");\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(_ix) {\n      throw new Error(\"System does not have state\");\n    }\n  }]);\n  return SystemStateCoder;\n}();\nvar SystemAccountsCoder = /*#__PURE__*/function () {\n  function SystemAccountsCoder(idl) {\n    _classCallCheck(this, SystemAccountsCoder);\n    this.idl = idl;\n  }\n  _createClass(SystemAccountsCoder, [{\n    key: \"encode\",\n    value: function () {\n      var _encode4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(accountName, account) {\n        var buffer, len;\n        return _regeneratorRuntime().wrap(function _callee8$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.t0 = accountName;\n              _context12.next = _context12.t0 === \"nonce\" ? 3 : 6;\n              break;\n            case 3:\n              buffer = Buffer.alloc(NONCE_ACCOUNT_LENGTH);\n              len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);\n              return _context12.abrupt(\"return\", buffer.slice(0, len));\n            case 6:\n              throw new Error(\"Invalid account name: \".concat(accountName));\n            case 7:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee8);\n      }));\n      function encode(_x36, _x37) {\n        return _encode4.apply(this, arguments);\n      }\n      return encode;\n    }()\n  }, {\n    key: \"decode\",\n    value: function decode(accountName, ix) {\n      return this.decodeUnchecked(accountName, ix);\n    }\n  }, {\n    key: \"decodeUnchecked\",\n    value: function decodeUnchecked(accountName, ix) {\n      switch (accountName) {\n        case \"nonce\":\n          {\n            return decodeNonceAccount(ix);\n          }\n        default:\n          {\n            throw new Error(\"Invalid account name: \".concat(accountName));\n          }\n      }\n    } // TODO: this won't use the appendData.\n  }, {\n    key: \"memcmp\",\n    value: function memcmp(accountName, _appendData) {\n      switch (accountName) {\n        case \"nonce\":\n          {\n            return {\n              dataSize: NONCE_ACCOUNT_LENGTH\n            };\n          }\n        default:\n          {\n            throw new Error(\"Invalid account name: \".concat(accountName));\n          }\n      }\n    }\n  }, {\n    key: \"size\",\n    value: function size(idlAccount) {\n      var _a;\n      return (_a = accountSize(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0;\n    }\n  }]);\n  return SystemAccountsCoder;\n}();\nfunction decodeNonceAccount(ix) {\n  return NONCE_ACCOUNT_LAYOUT.decode(ix);\n}\nvar WrappedLayout$1 = /*#__PURE__*/function (_Layout_2) {\n  _inherits(WrappedLayout$1, _Layout_2);\n  function WrappedLayout$1(layout, decoder, encoder, property) {\n    var _this19;\n    _classCallCheck(this, WrappedLayout$1);\n    _this19 = _possibleConstructorReturn(this, _getPrototypeOf(WrappedLayout$1).call(this, layout.span, property));\n    _this19.layout = layout;\n    _this19.decoder = decoder;\n    _this19.encoder = encoder;\n    return _this19;\n  }\n  _createClass(WrappedLayout$1, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      return this.decoder(this.layout.decode(b, offset));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      return this.layout.encode(this.encoder(src), b, offset);\n    }\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      return this.layout.getSpan(b, offset);\n    }\n  }]);\n  return WrappedLayout$1;\n}(Layout_2);\nfunction publicKey$1(property) {\n  return new WrappedLayout$1(blob(32), function (b) {\n    return new PublicKey(b);\n  }, function (key) {\n    return key.toBuffer();\n  }, property);\n}\nvar NONCE_ACCOUNT_LAYOUT = struct([u32(\"version\"), u32(\"state\"), publicKey$1(\"authorizedPubkey\"), publicKey$1(\"nonce\"), struct([nu64(\"lamportsPerSignature\")], \"feeCalculator\")]);\nvar SystemEventsCoder = /*#__PURE__*/function () {\n  function SystemEventsCoder(_idl) {\n    _classCallCheck(this, SystemEventsCoder);\n  }\n  _createClass(SystemEventsCoder, [{\n    key: \"decode\",\n    value: function decode(_log) {\n      throw new Error(\"System program does not have events\");\n    }\n  }]);\n  return SystemEventsCoder;\n}();\nvar SystemTypesCoder = /*#__PURE__*/function () {\n  function SystemTypesCoder(_idl) {\n    _classCallCheck(this, SystemTypesCoder);\n  }\n  _createClass(SystemTypesCoder, [{\n    key: \"encode\",\n    value: function encode(_name, _type) {\n      throw new Error(\"System does not have user-defined types\");\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(_name, _typeData) {\n      throw new Error(\"System does not have user-defined types\");\n    }\n  }]);\n  return SystemTypesCoder;\n}();\n/**\n * Coder for the System program.\n */\nvar SystemCoder = function SystemCoder(idl) {\n  _classCallCheck(this, SystemCoder);\n  this.instruction = new SystemInstructionCoder(idl);\n  this.accounts = new SystemAccountsCoder(idl);\n  this.events = new SystemEventsCoder(idl);\n  this.state = new SystemStateCoder(idl);\n  this.types = new SystemTypesCoder(idl);\n};\nfunction hash(data) {\n  return sha256$1(data);\n}\nvar sha256 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  hash: hash\n});\n\n// Sync version of web3.PublicKey.createWithSeed.\nfunction createWithSeedSync(fromPublicKey, seed, programId) {\n  var buffer = Buffer$1.concat([fromPublicKey.toBuffer(), Buffer$1.from(seed), programId.toBuffer()]);\n  var hash = sha256$1.digest(buffer);\n  return new PublicKey(Buffer$1.from(hash));\n}\n// Sync version of web3.PublicKey.createProgramAddress.\nfunction createProgramAddressSync(seeds, programId) {\n  var MAX_SEED_LENGTH = 32;\n  var buffer = Buffer$1.alloc(0);\n  seeds.forEach(function (seed) {\n    if (seed.length > MAX_SEED_LENGTH) {\n      throw new TypeError(\"Max seed length exceeded\");\n    }\n    buffer = Buffer$1.concat([buffer, toBuffer(seed)]);\n  });\n  buffer = Buffer$1.concat([buffer, programId.toBuffer(), Buffer$1.from(\"ProgramDerivedAddress\")]);\n  var hash = sha256$1(new Uint8Array(buffer));\n  var publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n  if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n    throw new Error(\"Invalid seeds, address must fall off the curve\");\n  }\n  return new PublicKey(publicKeyBytes);\n}\n// Sync version of web3.PublicKey.findProgramAddress.\nfunction findProgramAddressSync(seeds, programId) {\n  var nonce = 255;\n  var address;\n  while (nonce != 0) {\n    try {\n      var seedsWithNonce = seeds.concat(Buffer$1.from([nonce]));\n      address = createProgramAddressSync(seedsWithNonce, programId);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw err;\n      }\n      nonce--;\n      continue;\n    }\n    return [address, nonce];\n  }\n  throw new Error(\"Unable to find a viable program address nonce\");\n}\nvar toBuffer = function toBuffer(arr) {\n  if (arr instanceof Buffer$1) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer$1.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer$1.from(arr);\n  }\n};\nfunction associated(_x38) {\n  return _associated.apply(this, arguments);\n}\nfunction _associated() {\n  _associated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee61(programId) {\n    var seeds,\n      _len2,\n      args,\n      _key2,\n      _yield$PublicKey$find3,\n      _yield$PublicKey$find4,\n      assoc,\n      _args67 = arguments;\n    return _regeneratorRuntime().wrap(function _callee61$(_context66) {\n      while (1) switch (_context66.prev = _context66.next) {\n        case 0:\n          seeds = [Buffer$1.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n          for (_len2 = _args67.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = _args67[_key2];\n          }\n          args.forEach(function (arg) {\n            seeds.push(arg instanceof Buffer$1 ? arg : translateAddress(arg).toBuffer());\n          });\n          _context66.next = 5;\n          return PublicKey.findProgramAddress(seeds, translateAddress(programId));\n        case 5:\n          _yield$PublicKey$find3 = _context66.sent;\n          _yield$PublicKey$find4 = _slicedToArray(_yield$PublicKey$find3, 1);\n          assoc = _yield$PublicKey$find4[0];\n          return _context66.abrupt(\"return\", assoc);\n        case 9:\n        case \"end\":\n          return _context66.stop();\n      }\n    }, _callee61);\n  }));\n  return _associated.apply(this, arguments);\n}\nvar pubkey = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createWithSeedSync: createWithSeedSync,\n  createProgramAddressSync: createProgramAddressSync,\n  findProgramAddressSync: findProgramAddressSync,\n  associated: associated\n});\nvar TOKEN_PROGRAM_ID = new PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\nvar ASSOCIATED_PROGRAM_ID = new PublicKey(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");\nfunction associatedAddress(_x39) {\n  return _associatedAddress.apply(this, arguments);\n}\nfunction _associatedAddress() {\n  _associatedAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee62(_ref13) {\n    var mint, owner;\n    return _regeneratorRuntime().wrap(function _callee62$(_context67) {\n      while (1) switch (_context67.prev = _context67.next) {\n        case 0:\n          mint = _ref13.mint, owner = _ref13.owner;\n          _context67.next = 3;\n          return PublicKey.findProgramAddress([owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], ASSOCIATED_PROGRAM_ID);\n        case 3:\n          return _context67.abrupt(\"return\", _context67.sent[0]);\n        case 4:\n        case \"end\":\n          return _context67.stop();\n      }\n    }, _callee62);\n  }));\n  return _associatedAddress.apply(this, arguments);\n}\nvar token = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TOKEN_PROGRAM_ID: TOKEN_PROGRAM_ID,\n  ASSOCIATED_PROGRAM_ID: ASSOCIATED_PROGRAM_ID,\n  associatedAddress: associatedAddress\n});\nvar browserPonyfill = {\n  exports: {}\n};\n(function (module, exports) {\n  var global = typeof self !== 'undefined' ? self : commonjsGlobal;\n  var __self__ = function () {\n    function F() {\n      this.fetch = false;\n      this.DOMException = global.DOMException;\n    }\n    F.prototype = global;\n    return new F();\n  }();\n  (function (self) {\n    (function (exports) {\n      var support = {\n        searchParams: 'URLSearchParams' in self,\n        iterable: 'Symbol' in self && 'iterator' in Symbol,\n        blob: 'FileReader' in self && 'Blob' in self && function () {\n          try {\n            new Blob();\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }(),\n        formData: 'FormData' in self,\n        arrayBuffer: 'ArrayBuffer' in self\n      };\n      function isDataView(obj) {\n        return obj && DataView.prototype.isPrototypeOf(obj);\n      }\n      if (support.arrayBuffer) {\n        var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n        var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n        };\n      }\n      function normalizeName(name) {\n        if (typeof name !== 'string') {\n          name = String(name);\n        }\n        if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n          throw new TypeError('Invalid character in header field name');\n        }\n        return name.toLowerCase();\n      }\n      function normalizeValue(value) {\n        if (typeof value !== 'string') {\n          value = String(value);\n        }\n        return value;\n      }\n\n      // Build a destructive iterator for the value list\n      function iteratorFor(items) {\n        var iterator = {\n          next: function next() {\n            var value = items.shift();\n            return {\n              done: value === undefined,\n              value: value\n            };\n          }\n        };\n        if (support.iterable) {\n          iterator[Symbol.iterator] = function () {\n            return iterator;\n          };\n        }\n        return iterator;\n      }\n      function Headers(headers) {\n        this.map = {};\n        if (headers instanceof Headers) {\n          headers.forEach(function (value, name) {\n            this.append(name, value);\n          }, this);\n        } else if (Array.isArray(headers)) {\n          headers.forEach(function (header) {\n            this.append(header[0], header[1]);\n          }, this);\n        } else if (headers) {\n          Object.getOwnPropertyNames(headers).forEach(function (name) {\n            this.append(name, headers[name]);\n          }, this);\n        }\n      }\n      Headers.prototype.append = function (name, value) {\n        name = normalizeName(name);\n        value = normalizeValue(value);\n        var oldValue = this.map[name];\n        this.map[name] = oldValue ? oldValue + ', ' + value : value;\n      };\n      Headers.prototype['delete'] = function (name) {\n        delete this.map[normalizeName(name)];\n      };\n      Headers.prototype.get = function (name) {\n        name = normalizeName(name);\n        return this.has(name) ? this.map[name] : null;\n      };\n      Headers.prototype.has = function (name) {\n        return this.map.hasOwnProperty(normalizeName(name));\n      };\n      Headers.prototype.set = function (name, value) {\n        this.map[normalizeName(name)] = normalizeValue(value);\n      };\n      Headers.prototype.forEach = function (callback, thisArg) {\n        for (var name in this.map) {\n          if (this.map.hasOwnProperty(name)) {\n            callback.call(thisArg, this.map[name], name, this);\n          }\n        }\n      };\n      Headers.prototype.keys = function () {\n        var items = [];\n        this.forEach(function (value, name) {\n          items.push(name);\n        });\n        return iteratorFor(items);\n      };\n      Headers.prototype.values = function () {\n        var items = [];\n        this.forEach(function (value) {\n          items.push(value);\n        });\n        return iteratorFor(items);\n      };\n      Headers.prototype.entries = function () {\n        var items = [];\n        this.forEach(function (value, name) {\n          items.push([name, value]);\n        });\n        return iteratorFor(items);\n      };\n      if (support.iterable) {\n        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n      }\n      function consumed(body) {\n        if (body.bodyUsed) {\n          return Promise.reject(new TypeError('Already read'));\n        }\n        body.bodyUsed = true;\n      }\n      function fileReaderReady(reader) {\n        return new Promise(function (resolve, reject) {\n          reader.onload = function () {\n            resolve(reader.result);\n          };\n          reader.onerror = function () {\n            reject(reader.error);\n          };\n        });\n      }\n      function readBlobAsArrayBuffer(blob) {\n        var reader = new FileReader();\n        var promise = fileReaderReady(reader);\n        reader.readAsArrayBuffer(blob);\n        return promise;\n      }\n      function readBlobAsText(blob) {\n        var reader = new FileReader();\n        var promise = fileReaderReady(reader);\n        reader.readAsText(blob);\n        return promise;\n      }\n      function readArrayBufferAsText(buf) {\n        var view = new Uint8Array(buf);\n        var chars = new Array(view.length);\n        for (var i = 0; i < view.length; i++) {\n          chars[i] = String.fromCharCode(view[i]);\n        }\n        return chars.join('');\n      }\n      function bufferClone(buf) {\n        if (buf.slice) {\n          return buf.slice(0);\n        } else {\n          var view = new Uint8Array(buf.byteLength);\n          view.set(new Uint8Array(buf));\n          return view.buffer;\n        }\n      }\n      function Body() {\n        this.bodyUsed = false;\n        this._initBody = function (body) {\n          this._bodyInit = body;\n          if (!body) {\n            this._bodyText = '';\n          } else if (typeof body === 'string') {\n            this._bodyText = body;\n          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n            this._bodyBlob = body;\n          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n            this._bodyFormData = body;\n          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n            this._bodyText = body.toString();\n          } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n            this._bodyArrayBuffer = bufferClone(body.buffer);\n            // IE 10-11 can't handle a DataView body.\n            this._bodyInit = new Blob([this._bodyArrayBuffer]);\n          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n            this._bodyArrayBuffer = bufferClone(body);\n          } else {\n            this._bodyText = body = Object.prototype.toString.call(body);\n          }\n          if (!this.headers.get('content-type')) {\n            if (typeof body === 'string') {\n              this.headers.set('content-type', 'text/plain;charset=UTF-8');\n            } else if (this._bodyBlob && this._bodyBlob.type) {\n              this.headers.set('content-type', this._bodyBlob.type);\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n              this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n            }\n          }\n        };\n        if (support.blob) {\n          this.blob = function () {\n            var rejected = consumed(this);\n            if (rejected) {\n              return rejected;\n            }\n            if (this._bodyBlob) {\n              return Promise.resolve(this._bodyBlob);\n            } else if (this._bodyArrayBuffer) {\n              return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n            } else if (this._bodyFormData) {\n              throw new Error('could not read FormData body as blob');\n            } else {\n              return Promise.resolve(new Blob([this._bodyText]));\n            }\n          };\n          this.arrayBuffer = function () {\n            if (this._bodyArrayBuffer) {\n              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n            } else {\n              return this.blob().then(readBlobAsArrayBuffer);\n            }\n          };\n        }\n        this.text = function () {\n          var rejected = consumed(this);\n          if (rejected) {\n            return rejected;\n          }\n          if (this._bodyBlob) {\n            return readBlobAsText(this._bodyBlob);\n          } else if (this._bodyArrayBuffer) {\n            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n          } else if (this._bodyFormData) {\n            throw new Error('could not read FormData body as text');\n          } else {\n            return Promise.resolve(this._bodyText);\n          }\n        };\n        if (support.formData) {\n          this.formData = function () {\n            return this.text().then(decode);\n          };\n        }\n        this.json = function () {\n          return this.text().then(JSON.parse);\n        };\n        return this;\n      }\n\n      // HTTP methods whose capitalization should be normalized\n      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n      function normalizeMethod(method) {\n        var upcased = method.toUpperCase();\n        return methods.indexOf(upcased) > -1 ? upcased : method;\n      }\n      function Request(input, options) {\n        options = options || {};\n        var body = options.body;\n        if (input instanceof Request) {\n          if (input.bodyUsed) {\n            throw new TypeError('Already read');\n          }\n          this.url = input.url;\n          this.credentials = input.credentials;\n          if (!options.headers) {\n            this.headers = new Headers(input.headers);\n          }\n          this.method = input.method;\n          this.mode = input.mode;\n          this.signal = input.signal;\n          if (!body && input._bodyInit != null) {\n            body = input._bodyInit;\n            input.bodyUsed = true;\n          }\n        } else {\n          this.url = String(input);\n        }\n        this.credentials = options.credentials || this.credentials || 'same-origin';\n        if (options.headers || !this.headers) {\n          this.headers = new Headers(options.headers);\n        }\n        this.method = normalizeMethod(options.method || this.method || 'GET');\n        this.mode = options.mode || this.mode || null;\n        this.signal = options.signal || this.signal;\n        this.referrer = null;\n        if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n          throw new TypeError('Body not allowed for GET or HEAD requests');\n        }\n        this._initBody(body);\n      }\n      Request.prototype.clone = function () {\n        return new Request(this, {\n          body: this._bodyInit\n        });\n      };\n      function decode(body) {\n        var form = new FormData();\n        body.trim().split('&').forEach(function (bytes) {\n          if (bytes) {\n            var split = bytes.split('=');\n            var name = split.shift().replace(/\\+/g, ' ');\n            var value = split.join('=').replace(/\\+/g, ' ');\n            form.append(decodeURIComponent(name), decodeURIComponent(value));\n          }\n        });\n        return form;\n      }\n      function parseHeaders(rawHeaders) {\n        var headers = new Headers();\n        // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n        // https://tools.ietf.org/html/rfc7230#section-3.2\n        var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n        preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\n          var parts = line.split(':');\n          var key = parts.shift().trim();\n          if (key) {\n            var value = parts.join(':').trim();\n            headers.append(key, value);\n          }\n        });\n        return headers;\n      }\n      Body.call(Request.prototype);\n      function Response(bodyInit, options) {\n        if (!options) {\n          options = {};\n        }\n        this.type = 'default';\n        this.status = options.status === undefined ? 200 : options.status;\n        this.ok = this.status >= 200 && this.status < 300;\n        this.statusText = 'statusText' in options ? options.statusText : 'OK';\n        this.headers = new Headers(options.headers);\n        this.url = options.url || '';\n        this._initBody(bodyInit);\n      }\n      Body.call(Response.prototype);\n      Response.prototype.clone = function () {\n        return new Response(this._bodyInit, {\n          status: this.status,\n          statusText: this.statusText,\n          headers: new Headers(this.headers),\n          url: this.url\n        });\n      };\n      Response.error = function () {\n        var response = new Response(null, {\n          status: 0,\n          statusText: ''\n        });\n        response.type = 'error';\n        return response;\n      };\n      var redirectStatuses = [301, 302, 303, 307, 308];\n      Response.redirect = function (url, status) {\n        if (redirectStatuses.indexOf(status) === -1) {\n          throw new RangeError('Invalid status code');\n        }\n        return new Response(null, {\n          status: status,\n          headers: {\n            location: url\n          }\n        });\n      };\n      exports.DOMException = self.DOMException;\n      try {\n        new exports.DOMException();\n      } catch (err) {\n        exports.DOMException = function (message, name) {\n          this.message = message;\n          this.name = name;\n          var error = Error(message);\n          this.stack = error.stack;\n        };\n        exports.DOMException.prototype = Object.create(Error.prototype);\n        exports.DOMException.prototype.constructor = exports.DOMException;\n      }\n      function fetch(input, init) {\n        return new Promise(function (resolve, reject) {\n          var request = new Request(input, init);\n          if (request.signal && request.signal.aborted) {\n            return reject(new exports.DOMException('Aborted', 'AbortError'));\n          }\n          var xhr = new XMLHttpRequest();\n          function abortXhr() {\n            xhr.abort();\n          }\n          xhr.onload = function () {\n            var options = {\n              status: xhr.status,\n              statusText: xhr.statusText,\n              headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n            };\n            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n            var body = 'response' in xhr ? xhr.response : xhr.responseText;\n            resolve(new Response(body, options));\n          };\n          xhr.onerror = function () {\n            reject(new TypeError('Network request failed'));\n          };\n          xhr.ontimeout = function () {\n            reject(new TypeError('Network request failed'));\n          };\n          xhr.onabort = function () {\n            reject(new exports.DOMException('Aborted', 'AbortError'));\n          };\n          xhr.open(request.method, request.url, true);\n          if (request.credentials === 'include') {\n            xhr.withCredentials = true;\n          } else if (request.credentials === 'omit') {\n            xhr.withCredentials = false;\n          }\n          if ('responseType' in xhr && support.blob) {\n            xhr.responseType = 'blob';\n          }\n          request.headers.forEach(function (value, name) {\n            xhr.setRequestHeader(name, value);\n          });\n          if (request.signal) {\n            request.signal.addEventListener('abort', abortXhr);\n            xhr.onreadystatechange = function () {\n              // DONE (success or failure)\n              if (xhr.readyState === 4) {\n                request.signal.removeEventListener('abort', abortXhr);\n              }\n            };\n          }\n          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n        });\n      }\n      fetch.polyfill = true;\n      if (!self.fetch) {\n        self.fetch = fetch;\n        self.Headers = Headers;\n        self.Request = Request;\n        self.Response = Response;\n      }\n      exports.Headers = Headers;\n      exports.Request = Request;\n      exports.Response = Response;\n      exports.fetch = fetch;\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      return exports;\n    })({});\n  })(__self__);\n  __self__.fetch.ponyfill = true;\n  // Remove \"polyfill\" property added by whatwg-fetch\n  delete __self__.fetch.polyfill;\n  // Choose between native implementation (global) or custom implementation (__self__)\n  // var ctx = global.fetch ? global : __self__;\n  var ctx = __self__; // this line disable service worker support temporarily\n  exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'\n  exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.\n  exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'\n  exports.Headers = ctx.Headers;\n  exports.Request = ctx.Request;\n  exports.Response = ctx.Response;\n  module.exports = exports;\n})(browserPonyfill, browserPonyfill.exports);\nvar fetch = /*@__PURE__*/getDefaultExportFromCjs(browserPonyfill.exports);\n\n/**\n * Returns a verified build from the anchor registry. null if no such\n * verified build exists, e.g., if the program has been upgraded since the\n * last verified build.\n */\nfunction verifiedBuild(_x40, _x41) {\n  return _verifiedBuild.apply(this, arguments);\n}\n/**\n * Returns the program data account for this program, containing the\n * metadata for this program, e.g., the upgrade authority.\n */\nfunction _verifiedBuild() {\n  _verifiedBuild = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee63(connection, programId) {\n    var limit,\n      url,\n      _yield$Promise$all,\n      _yield$Promise$all2,\n      programData,\n      latestBuildsResp,\n      latestBuilds,\n      build,\n      _args69 = arguments;\n    return _regeneratorRuntime().wrap(function _callee63$(_context68) {\n      while (1) switch (_context68.prev = _context68.next) {\n        case 0:\n          limit = _args69.length > 2 && _args69[2] !== undefined ? _args69[2] : 5;\n          url = \"https://api.apr.dev/api/v0/program/\".concat(programId.toString(), \"/latest?limit=\").concat(limit);\n          _context68.next = 4;\n          return Promise.all([fetchData(connection, programId), fetch(url)]);\n        case 4:\n          _yield$Promise$all = _context68.sent;\n          _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n          programData = _yield$Promise$all2[0];\n          latestBuildsResp = _yield$Promise$all2[1];\n          _context68.next = 10;\n          return latestBuildsResp.json();\n        case 10:\n          latestBuilds = _context68.sent.filter(function (b) {\n            return !b.aborted && b.state === \"Built\" && b.verified === \"Verified\";\n          });\n          if (!(latestBuilds.length === 0)) {\n            _context68.next = 13;\n            break;\n          }\n          return _context68.abrupt(\"return\", null);\n        case 13:\n          // Get the latest build.\n          build = latestBuilds[0]; // Has the program been upgraded since the last build?\n          if (!(programData.slot.toNumber() !== build.verified_slot)) {\n            _context68.next = 16;\n            break;\n          }\n          return _context68.abrupt(\"return\", null);\n        case 16:\n          return _context68.abrupt(\"return\", build);\n        case 17:\n        case \"end\":\n          return _context68.stop();\n      }\n    }, _callee63);\n  }));\n  return _verifiedBuild.apply(this, arguments);\n}\nfunction fetchData(_x42, _x43) {\n  return _fetchData.apply(this, arguments);\n}\nfunction _fetchData() {\n  _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee64(connection, programId) {\n    var accountInfo, _decodeUpgradeableLoa, program, programdataAccountInfo, _decodeUpgradeableLoa2, programData;\n    return _regeneratorRuntime().wrap(function _callee64$(_context69) {\n      while (1) switch (_context69.prev = _context69.next) {\n        case 0:\n          _context69.next = 2;\n          return connection.getAccountInfo(programId);\n        case 2:\n          accountInfo = _context69.sent;\n          if (!(accountInfo === null)) {\n            _context69.next = 5;\n            break;\n          }\n          throw new Error(\"program account not found\");\n        case 5:\n          _decodeUpgradeableLoa = decodeUpgradeableLoaderState(accountInfo.data), program = _decodeUpgradeableLoa.program;\n          _context69.next = 8;\n          return connection.getAccountInfo(program.programdataAddress);\n        case 8:\n          programdataAccountInfo = _context69.sent;\n          if (!(programdataAccountInfo === null)) {\n            _context69.next = 11;\n            break;\n          }\n          throw new Error(\"program data account not found\");\n        case 11:\n          _decodeUpgradeableLoa2 = decodeUpgradeableLoaderState(programdataAccountInfo.data), programData = _decodeUpgradeableLoa2.programData;\n          return _context69.abrupt(\"return\", programData);\n        case 13:\n        case \"end\":\n          return _context69.stop();\n      }\n    }, _callee64);\n  }));\n  return _fetchData.apply(this, arguments);\n}\nvar UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([borsh.struct([], \"uninitialized\"), borsh.struct([borsh.option(borsh.publicKey(), \"authorityAddress\")], \"buffer\"), borsh.struct([borsh.publicKey(\"programdataAddress\")], \"program\"), borsh.struct([borsh.u64(\"slot\"), borsh.option(borsh.publicKey(), \"upgradeAuthorityAddress\")], \"programData\")], undefined, borsh.u32());\nfunction decodeUpgradeableLoaderState(data) {\n  return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);\n}\nvar registry = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  verifiedBuild: verifiedBuild,\n  fetchData: fetchData,\n  decodeUpgradeableLoaderState: decodeUpgradeableLoaderState\n});\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sha256: sha256,\n  rpc: rpc,\n  publicKey: pubkey,\n  bytes: index$1,\n  token: token,\n  features: features,\n  registry: registry\n});\nfunction isIdlAccounts(accountItem) {\n  return \"accounts\" in accountItem;\n}\n// Deterministic IDL address as a function of the program id.\nfunction idlAddress(_x44) {\n  return _idlAddress.apply(this, arguments);\n} // Seed for generating the idlAddress.\nfunction _idlAddress() {\n  _idlAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee65(programId) {\n    var base;\n    return _regeneratorRuntime().wrap(function _callee65$(_context70) {\n      while (1) switch (_context70.prev = _context70.next) {\n        case 0:\n          _context70.next = 2;\n          return PublicKey.findProgramAddress([], programId);\n        case 2:\n          base = _context70.sent[0];\n          _context70.next = 5;\n          return PublicKey.createWithSeed(base, seed(), programId);\n        case 5:\n          return _context70.abrupt(\"return\", _context70.sent);\n        case 6:\n        case \"end\":\n          return _context70.stop();\n      }\n    }, _callee65);\n  }));\n  return _idlAddress.apply(this, arguments);\n}\nfunction seed() {\n  return \"anchor:idl\";\n}\nvar IDL_ACCOUNT_LAYOUT = borsh.struct([borsh.publicKey(\"authority\"), borsh.vecU8(\"data\")]);\nfunction decodeIdlAccount(data) {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\nfunction splitArgsAndCtx(idlIx, args) {\n  var _a, _b;\n  var options = {};\n  var inputLen = idlIx.args ? idlIx.args.length : 0;\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(\"provided too many arguments \".concat(args, \" to instruction \").concat(idlIx === null || idlIx === void 0 ? void 0 : idlIx.name, \" expecting: \").concat((_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map(function (a) {\n        return a.name;\n      })) !== null && _b !== void 0 ? _b : []));\n    }\n    options = args.pop();\n  }\n  return [args, options];\n}\nvar InstructionNamespaceFactory = /*#__PURE__*/function () {\n  function InstructionNamespaceFactory() {\n    _classCallCheck(this, InstructionNamespaceFactory);\n  }\n  _createClass(InstructionNamespaceFactory, null, [{\n    key: \"build\",\n    value: function build(idlIx, encodeFn, programId) {\n      if (idlIx.name === \"_inner\") {\n        throw new IdlError(\"the _inner name is reserved\");\n      }\n      var ix = function ix() {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        var _splitArgsAndCtx = splitArgsAndCtx(idlIx, [].concat(args)),\n          _splitArgsAndCtx2 = _slicedToArray(_splitArgsAndCtx, 2),\n          ixArgs = _splitArgsAndCtx2[0],\n          ctx = _splitArgsAndCtx2[1];\n        validateAccounts(idlIx.accounts, ctx.accounts);\n        validateInstruction.apply(void 0, [idlIx].concat(args));\n        var keys = ix.accounts(ctx.accounts);\n        if (ctx.remainingAccounts !== undefined) {\n          keys.push.apply(keys, _toConsumableArray(ctx.remainingAccounts));\n        }\n        if (isSet(\"debug-logs\")) {\n          console.log(\"Outgoing account metas:\", keys);\n        }\n        return new TransactionInstruction({\n          keys: keys,\n          programId: programId,\n          data: encodeFn(idlIx.name, toInstruction.apply(void 0, [idlIx].concat(_toConsumableArray(ixArgs))))\n        });\n      };\n      // Utility fn for ordering the accounts for this instruction.\n      ix[\"accounts\"] = function (accs) {\n        return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);\n      };\n      return ix;\n    }\n  }, {\n    key: \"accountsArray\",\n    value: function accountsArray(ctx, accounts, programId, ixName) {\n      if (!ctx) {\n        return [];\n      }\n      return accounts.map(function (acc) {\n        // Nested accounts.\n        var nestedAccounts = \"accounts\" in acc ? acc.accounts : undefined;\n        if (nestedAccounts !== undefined) {\n          var rpcAccs = ctx[acc.name];\n          return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();\n        } else {\n          var account = acc;\n          var _pubkey;\n          try {\n            _pubkey = translateAddress(ctx[acc.name]);\n          } catch (err) {\n            throw new Error(\"Wrong input type for account \\\"\".concat(acc.name, \"\\\" in the instruction accounts object\").concat(ixName !== undefined ? ' for instruction \"' + ixName + '\"' : \"\", \". Expected PublicKey or string.\"));\n          }\n          var _optional = account.isOptional && _pubkey.equals(programId);\n          var isWritable = account.isMut && !_optional;\n          var isSigner = account.isSigner && !_optional;\n          return {\n            pubkey: _pubkey,\n            isWritable: isWritable,\n            isSigner: isSigner\n          };\n        }\n      }).flat();\n    }\n  }]);\n  return InstructionNamespaceFactory;\n}(); // Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix) {\n  // todo\n}\nvar RpcFactory = /*#__PURE__*/function () {\n  function RpcFactory() {\n    _classCallCheck(this, RpcFactory);\n  }\n  _createClass(RpcFactory, null, [{\n    key: \"build\",\n    value: function build(idlIx, txFn, idlErrors, provider) {\n      var rpc = /*#__PURE__*/function () {\n        var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n          var _a,\n            _len4,\n            args,\n            _key4,\n            tx,\n            _splitArgsAndCtx3,\n            _splitArgsAndCtx4,\n            ctx,\n            _args14 = arguments;\n          return _regeneratorRuntime().wrap(function _callee9$(_context13) {\n            while (1) switch (_context13.prev = _context13.next) {\n              case 0:\n                for (_len4 = _args14.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                  args[_key4] = _args14[_key4];\n                }\n                tx = txFn.apply(void 0, args);\n                _splitArgsAndCtx3 = splitArgsAndCtx(idlIx, [].concat(args)), _splitArgsAndCtx4 = _slicedToArray(_splitArgsAndCtx3, 2), ctx = _splitArgsAndCtx4[1];\n                if (!(provider.sendAndConfirm === undefined)) {\n                  _context13.next = 5;\n                  break;\n                }\n                throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");\n              case 5:\n                _context13.prev = 5;\n                _context13.next = 8;\n                return provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== void 0 ? _a : [], ctx.options);\n              case 8:\n                return _context13.abrupt(\"return\", _context13.sent);\n              case 11:\n                _context13.prev = 11;\n                _context13.t0 = _context13[\"catch\"](5);\n                throw translateError(_context13.t0, idlErrors);\n              case 14:\n              case \"end\":\n                return _context13.stop();\n            }\n          }, _callee9, null, [[5, 11]]);\n        }));\n        return function rpc() {\n          return _ref14.apply(this, arguments);\n        };\n      }();\n      return rpc;\n    }\n  }]);\n  return RpcFactory;\n}();\nvar TransactionFactory = /*#__PURE__*/function () {\n  function TransactionFactory() {\n    _classCallCheck(this, TransactionFactory);\n  }\n  _createClass(TransactionFactory, null, [{\n    key: \"build\",\n    value: function build(idlIx, ixFn) {\n      var txFn = function txFn() {\n        var _a, _b, _c;\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        var _splitArgsAndCtx5 = splitArgsAndCtx(idlIx, [].concat(args)),\n          _splitArgsAndCtx6 = _slicedToArray(_splitArgsAndCtx5, 2),\n          ctx = _splitArgsAndCtx6[1];\n        var tx = new Transaction();\n        if (ctx.preInstructions && ctx.instructions) {\n          throw new Error(\"instructions is deprecated, use preInstructions\");\n        }\n        (_a = ctx.preInstructions) === null || _a === void 0 ? void 0 : _a.forEach(function (ix) {\n          return tx.add(ix);\n        });\n        (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach(function (ix) {\n          return tx.add(ix);\n        });\n        tx.add(ixFn.apply(void 0, args));\n        (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach(function (ix) {\n          return tx.add(ix);\n        });\n        return tx;\n      };\n      return txFn;\n    }\n  }]);\n  return TransactionFactory;\n}();\nvar StateFactory = /*#__PURE__*/function () {\n  function StateFactory() {\n    _classCallCheck(this, StateFactory);\n  }\n  _createClass(StateFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      if (idl.state === undefined) {\n        return undefined;\n      }\n      return new StateClient(idl, programId, provider, coder);\n    }\n  }]);\n  return StateFactory;\n}();\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nvar StateClient = /*#__PURE__*/function () {\n  _createClass(StateClient, [{\n    key: \"programId\",\n    /**\n     * Returns the program ID owning the state.\n     */\n    get: function get() {\n      return this._programId;\n    }\n  }]);\n  function StateClient(idl, programId) {\n    var provider = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getProvider();\n    var coder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new BorshCoder(idl);\n    _classCallCheck(this, StateClient);\n    this.provider = provider;\n    this.coder = coder;\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n    // Build namespaces.\n    var _ref15 = function () {\n        var _a;\n        var instruction = {};\n        var transaction = {};\n        var rpc = {};\n        (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach(function (m) {\n          // Build instruction method.\n          var ixItem = InstructionNamespaceFactory.build(m, function (ixName, ix) {\n            return coder.instruction.encodeState(ixName, ix);\n          }, programId);\n          ixItem[\"accounts\"] = function (accounts) {\n            var keys = stateInstructionKeys(programId, provider, m, accounts);\n            return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts, programId, m.name));\n          };\n          // Build transaction method.\n          var txItem = TransactionFactory.build(m, ixItem);\n          // Build RPC method.\n          var rpcItem = RpcFactory.build(m, txItem, parseIdlErrors(idl), provider);\n          // Attach them all to their respective namespaces.\n          var name = camelCase(m.name);\n          instruction[name] = ixItem;\n          transaction[name] = txItem;\n          rpc[name] = rpcItem;\n        });\n        return [instruction, transaction, rpc];\n      }(),\n      _ref16 = _slicedToArray(_ref15, 3),\n      instruction = _ref16[0],\n      transaction = _ref16[1],\n      rpc = _ref16[2];\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the deserialized state account.\n   */\n  _createClass(StateClient, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var addr, accountInfo, state, expectedDiscriminator;\n        return _regeneratorRuntime().wrap(function _callee10$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              addr = this.address();\n              _context14.next = 3;\n              return this.provider.connection.getAccountInfo(addr);\n            case 3:\n              accountInfo = _context14.sent;\n              if (!(accountInfo === null)) {\n                _context14.next = 6;\n                break;\n              }\n              throw new Error(\"Account does not exist \".concat(addr.toString()));\n            case 6:\n              // Assert the account discriminator is correct.\n              state = this._idl.state;\n              if (state) {\n                _context14.next = 9;\n                break;\n              }\n              throw new Error(\"State is not specified in IDL.\");\n            case 9:\n              _context14.next = 11;\n              return stateDiscriminator(state.struct.name);\n            case 11:\n              expectedDiscriminator = _context14.sent;\n              if (!expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n                _context14.next = 14;\n                break;\n              }\n              throw new Error(\"Invalid account discriminator\");\n            case 14:\n              return _context14.abrupt(\"return\", this.coder.state.decode(accountInfo.data));\n            case 15:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee10, this);\n      }));\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n    /**\n     * Returns the state address.\n     */\n  }, {\n    key: \"address\",\n    value: function address() {\n      return this._address;\n    }\n    /**\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n     * the state account cahnges.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(commitment) {\n      var _this20 = this;\n      if (this._sub !== null) {\n        return this._sub.ee;\n      }\n      var ee = new EventEmitter();\n      var listener = this.provider.connection.onAccountChange(this.address(), function (acc) {\n        var account = _this20.coder.state.decode(acc.data);\n        ee.emit(\"change\", account);\n      }, commitment);\n      this._sub = {\n        ee: ee,\n        listener: listener\n      };\n      return ee;\n    }\n    /**\n     * Unsubscribes to state changes.\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this21 = this;\n      if (this._sub !== null) {\n        this.provider.connection.removeAccountChangeListener(this._sub.listener).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n          return _regeneratorRuntime().wrap(function _callee11$(_context15) {\n            while (1) switch (_context15.prev = _context15.next) {\n              case 0:\n                _this21._sub = null;\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }, _callee11);\n        }))).catch(console.error);\n      }\n    }\n  }]);\n  return StateClient;\n}(); // Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n  var _findProgramAddressSy = findProgramAddressSync([], programId),\n    _findProgramAddressSy2 = _slicedToArray(_findProgramAddressSy, 1),\n    registrySigner = _findProgramAddressSy2[0];\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    var _findProgramAddressSy3 = findProgramAddressSync([], programId),\n      _findProgramAddressSy4 = _slicedToArray(_findProgramAddressSy3, 1),\n      programSigner = _findProgramAddressSy4[0]; // @ts-expect-error\n    if (provider.wallet === undefined) {\n      throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n    }\n    return [{\n      // @ts-expect-error\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}\nvar AccountFactory = /*#__PURE__*/function () {\n  function AccountFactory() {\n    _classCallCheck(this, AccountFactory);\n  }\n  _createClass(AccountFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      var _a;\n      var accountFns = {};\n      (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach(function (idlAccount) {\n        var name = camelCase(idlAccount.name);\n        accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n      });\n      return accountFns;\n    }\n  }]);\n  return AccountFactory;\n}();\nvar AccountClient = /*#__PURE__*/function () {\n  _createClass(AccountClient, [{\n    key: \"size\",\n    /**\n     * Returns the number of bytes in this account.\n     */\n    get: function get() {\n      return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n  }, {\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n  }]);\n  function AccountClient(idl, idlAccount, programId, provider, coder) {\n    _classCallCheck(this, AccountClient);\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(idl);\n    this._size = this._coder.accounts.size(idlAccount);\n  }\n  /**\n   * Returns a deserialized account, returning null if it doesn't exist.\n   *\n   * @param address The address of the account to fetch.\n   */\n  _createClass(AccountClient, [{\n    key: \"fetchNullable\",\n    value: function () {\n      var _fetchNullable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(address, commitment) {\n        var _yield$this$fetchNull, data;\n        return _regeneratorRuntime().wrap(function _callee12$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return this.fetchNullableAndContext(address, commitment);\n            case 2:\n              _yield$this$fetchNull = _context16.sent;\n              data = _yield$this$fetchNull.data;\n              return _context16.abrupt(\"return\", data);\n            case 5:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee12, this);\n      }));\n      function fetchNullable(_x45, _x46) {\n        return _fetchNullable.apply(this, arguments);\n      }\n      return fetchNullable;\n    }()\n    /**\n     * Returns a deserialized account along with the associated rpc response context, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */\n  }, {\n    key: \"fetchNullableAndContext\",\n    value: function () {\n      var _fetchNullableAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(address, commitment) {\n        var accountInfo, value, context;\n        return _regeneratorRuntime().wrap(function _callee13$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return this.getAccountInfoAndContext(address, commitment);\n            case 2:\n              accountInfo = _context17.sent;\n              value = accountInfo.value, context = accountInfo.context;\n              return _context17.abrupt(\"return\", {\n                data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,\n                context: context\n              });\n            case 5:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee13, this);\n      }));\n      function fetchNullableAndContext(_x47, _x48) {\n        return _fetchNullableAndContext.apply(this, arguments);\n      }\n      return fetchNullableAndContext;\n    }()\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(address, commitment) {\n        var _yield$this$fetchNull2, data;\n        return _regeneratorRuntime().wrap(function _callee14$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return this.fetchNullableAndContext(address, commitment);\n            case 2:\n              _yield$this$fetchNull2 = _context18.sent;\n              data = _yield$this$fetchNull2.data;\n              if (!(data === null)) {\n                _context18.next = 6;\n                break;\n              }\n              throw new Error(\"Account does not exist or has no data \".concat(address.toString()));\n            case 6:\n              return _context18.abrupt(\"return\", data);\n            case 7:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee14, this);\n      }));\n      function fetch(_x49, _x50) {\n        return _fetch2.apply(this, arguments);\n      }\n      return fetch;\n    }()\n    /**\n     * Returns a deserialized account along with the associated rpc response context.\n     *\n     * @param address The address of the account to fetch.\n     */\n  }, {\n    key: \"fetchAndContext\",\n    value: function () {\n      var _fetchAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(address, commitment) {\n        var _yield$this$fetchNull3, data, context;\n        return _regeneratorRuntime().wrap(function _callee15$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return this.fetchNullableAndContext(address, commitment);\n            case 2:\n              _yield$this$fetchNull3 = _context19.sent;\n              data = _yield$this$fetchNull3.data;\n              context = _yield$this$fetchNull3.context;\n              if (!(data === null)) {\n                _context19.next = 7;\n                break;\n              }\n              throw new Error(\"Account does not exist \".concat(address.toString()));\n            case 7:\n              return _context19.abrupt(\"return\", {\n                data: data,\n                context: context\n              });\n            case 8:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee15, this);\n      }));\n      function fetchAndContext(_x51, _x52) {\n        return _fetchAndContext.apply(this, arguments);\n      }\n      return fetchAndContext;\n    }()\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */\n  }, {\n    key: \"fetchMultiple\",\n    value: function () {\n      var _fetchMultiple = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(addresses, commitment) {\n        var accounts;\n        return _regeneratorRuntime().wrap(function _callee16$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return this.fetchMultipleAndContext(addresses, commitment);\n            case 2:\n              accounts = _context20.sent;\n              return _context20.abrupt(\"return\", accounts.map(function (account) {\n                return account ? account.data : null;\n              }));\n            case 4:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee16, this);\n      }));\n      function fetchMultiple(_x53, _x54) {\n        return _fetchMultiple.apply(this, arguments);\n      }\n      return fetchMultiple;\n    }()\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */\n  }, {\n    key: \"fetchMultipleAndContext\",\n    value: function () {\n      var _fetchMultipleAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(addresses, commitment) {\n        var _this22 = this;\n        var accounts;\n        return _regeneratorRuntime().wrap(function _callee17$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return getMultipleAccountsAndContext(this._provider.connection, addresses.map(function (address) {\n                return translateAddress(address);\n              }), commitment);\n            case 2:\n              accounts = _context21.sent;\n              return _context21.abrupt(\"return\", accounts.map(function (result) {\n                if (result == null) {\n                  return null;\n                }\n                var account = result.account,\n                  context = result.context;\n                return {\n                  data: _this22._coder.accounts.decode(_this22._idlAccount.name, account.data),\n                  context: context\n                };\n              }));\n            case 4:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee17, this);\n      }));\n      function fetchMultipleAndContext(_x55, _x56) {\n        return _fetchMultipleAndContext.apply(this, arguments);\n      }\n      return fetchMultipleAndContext;\n    }()\n    /**\n     * Returns all instances of this account type for the program.\n     *\n     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n     *\n     *                When filters are not defined this method returns all\n     *                the account instances.\n     *\n     *                When filters are of type `Buffer`, the filters are appended\n     *                after the discriminator.\n     *\n     *                When filters are of type `GetProgramAccountsFilter[]`,\n     *                filters are appended after the discriminator filter.\n     */\n  }, {\n    key: \"all\",\n    value: function () {\n      var _all = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(filters) {\n        var _this23 = this;\n        var filter, coderFilters, resp;\n        return _regeneratorRuntime().wrap(function _callee18$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : undefined);\n              coderFilters = [];\n              if ((filter === null || filter === void 0 ? void 0 : filter.offset) != undefined && (filter === null || filter === void 0 ? void 0 : filter.bytes) != undefined) {\n                coderFilters.push({\n                  memcmp: {\n                    offset: filter.offset,\n                    bytes: filter.bytes\n                  }\n                });\n              }\n              if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != undefined) {\n                coderFilters.push({\n                  dataSize: filter.dataSize\n                });\n              }\n              _context22.next = 6;\n              return this._provider.connection.getProgramAccounts(this._programId, {\n                commitment: this._provider.connection.commitment,\n                filters: [].concat(coderFilters, _toConsumableArray(Array.isArray(filters) ? filters : []))\n              });\n            case 6:\n              resp = _context22.sent;\n              return _context22.abrupt(\"return\", resp.map(function (_ref18) {\n                var pubkey = _ref18.pubkey,\n                  account = _ref18.account;\n                return {\n                  publicKey: pubkey,\n                  account: _this23._coder.accounts.decode(_this23._idlAccount.name, account.data)\n                };\n              }));\n            case 8:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee18, this);\n      }));\n      function all(_x57) {\n        return _all.apply(this, arguments);\n      }\n      return all;\n    }()\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(address, commitment) {\n      var _this24 = this;\n      var sub = subscriptions.get(address.toString());\n      if (sub) {\n        return sub.ee;\n      }\n      var ee = new EventEmitter();\n      address = translateAddress(address);\n      var listener = this._provider.connection.onAccountChange(address, function (acc) {\n        var account = _this24._coder.accounts.decode(_this24._idlAccount.name, acc.data);\n        ee.emit(\"change\", account);\n      }, commitment);\n      subscriptions.set(address.toString(), {\n        ee: ee,\n        listener: listener\n      });\n      return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(address) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee19$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              sub = subscriptions.get(address.toString());\n              if (sub) {\n                _context23.next = 4;\n                break;\n              }\n              console.warn(\"Address is not subscribed\");\n              return _context23.abrupt(\"return\");\n            case 4:\n              if (!subscriptions) {\n                _context23.next = 7;\n                break;\n              }\n              _context23.next = 7;\n              return this._provider.connection.removeAccountChangeListener(sub.listener).then(function () {\n                subscriptions.delete(address.toString());\n              }).catch(console.error);\n            case 7:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee19, this);\n      }));\n      function unsubscribe(_x58) {\n        return _unsubscribe.apply(this, arguments);\n      }\n      return unsubscribe;\n    }()\n    /**\n     * Returns an instruction for creating this account.\n     */\n  }, {\n    key: \"createInstruction\",\n    value: function () {\n      var _createInstruction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(signer, sizeOverride) {\n        var size;\n        return _regeneratorRuntime().wrap(function _callee20$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              size = this.size;\n              if (!(this._provider.publicKey === undefined)) {\n                _context24.next = 3;\n                break;\n              }\n              throw new Error(\"This function requires the Provider interface implementor to have a 'publicKey' field.\");\n            case 3:\n              _context24.t0 = SystemProgram;\n              _context24.t1 = this._provider.publicKey;\n              _context24.t2 = signer.publicKey;\n              _context24.t3 = sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size;\n              _context24.next = 9;\n              return this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size);\n            case 9:\n              _context24.t4 = _context24.sent;\n              _context24.t5 = this._programId;\n              _context24.t6 = {\n                fromPubkey: _context24.t1,\n                newAccountPubkey: _context24.t2,\n                space: _context24.t3,\n                lamports: _context24.t4,\n                programId: _context24.t5\n              };\n              return _context24.abrupt(\"return\", _context24.t0.createAccount.call(_context24.t0, _context24.t6));\n            case 13:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee20, this);\n      }));\n      function createInstruction(_x59, _x60) {\n        return _createInstruction.apply(this, arguments);\n      }\n      return createInstruction;\n    }()\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n  }, {\n    key: \"associated\",\n    value: function () {\n      var _associated2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var addr,\n          _args26 = arguments;\n        return _regeneratorRuntime().wrap(function _callee21$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              _context25.next = 2;\n              return this.associatedAddress.apply(this, _args26);\n            case 2:\n              addr = _context25.sent;\n              _context25.next = 5;\n              return this.fetch(addr);\n            case 5:\n              return _context25.abrupt(\"return\", _context25.sent);\n            case 6:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee21, this);\n      }));\n      function associated() {\n        return _associated2.apply(this, arguments);\n      }\n      return associated;\n    }()\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated address. Args are keys to associate.\n     * Order matters.\n     */\n  }, {\n    key: \"associatedAddress\",\n    value: function () {\n      var _associatedAddress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var _len6,\n          args,\n          _key6,\n          _args27 = arguments;\n        return _regeneratorRuntime().wrap(function _callee22$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              for (_len6 = _args27.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n                args[_key6] = _args27[_key6];\n              }\n              _context26.next = 3;\n              return associated.apply(void 0, [this._programId].concat(args));\n            case 3:\n              return _context26.abrupt(\"return\", _context26.sent);\n            case 4:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee22, this);\n      }));\n      function associatedAddress() {\n        return _associatedAddress2.apply(this, arguments);\n      }\n      return associatedAddress;\n    }()\n  }, {\n    key: \"getAccountInfo\",\n    value: function () {\n      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(address, commitment) {\n        return _regeneratorRuntime().wrap(function _callee23$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              _context27.next = 2;\n              return this._provider.connection.getAccountInfo(translateAddress(address), commitment);\n            case 2:\n              return _context27.abrupt(\"return\", _context27.sent);\n            case 3:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee23, this);\n      }));\n      function getAccountInfo(_x61, _x62) {\n        return _getAccountInfo.apply(this, arguments);\n      }\n      return getAccountInfo;\n    }()\n  }, {\n    key: \"getAccountInfoAndContext\",\n    value: function () {\n      var _getAccountInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(address, commitment) {\n        return _regeneratorRuntime().wrap(function _callee24$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              _context28.next = 2;\n              return this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);\n            case 2:\n              return _context28.abrupt(\"return\", _context28.sent);\n            case 3:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee24, this);\n      }));\n      function getAccountInfoAndContext(_x63, _x64) {\n        return _getAccountInfoAndContext.apply(this, arguments);\n      }\n      return getAccountInfoAndContext;\n    }()\n  }]);\n  return AccountClient;\n}(); // Tracks all subscriptions.\nvar subscriptions = new Map();\nvar PROGRAM_LOG = \"Program log: \";\nvar PROGRAM_DATA = \"Program data: \";\nvar PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;\nvar PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager(programId, provider, coder) {\n    _classCallCheck(this, EventManager);\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n  _createClass(EventManager, [{\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, callback) {\n      var _this25 = this;\n      var _a;\n      var listener = this._listenerIdCount;\n      this._listenerIdCount += 1;\n      // Store the listener into the event map.\n      if (!this._eventListeners.has(eventName)) {\n        this._eventListeners.set(eventName, []);\n      }\n      this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n      // Store the callback into the listener map.\n      this._eventCallbacks.set(listener, [eventName, callback]);\n      // Create the subscription singleton, if needed.\n      if (this._onLogsSubscriptionId !== undefined) {\n        return listener;\n      }\n      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, function (logs, ctx) {\n        if (logs.err) {\n          return;\n        }\n        var _iterator16 = _createForOfIteratorHelper(_this25._eventParser.parseLogs(logs.logs)),\n          _step16;\n        try {\n          var _loop = function _loop() {\n            var event = _step16.value;\n            var allListeners = _this25._eventListeners.get(event.name);\n            if (allListeners) {\n              allListeners.forEach(function (listener) {\n                var listenerCb = _this25._eventCallbacks.get(listener);\n                if (listenerCb) {\n                  var _listenerCb = _slicedToArray(listenerCb, 2),\n                    _callback = _listenerCb[1];\n                  _callback(event.data, ctx.slot, logs.signature);\n                }\n              });\n            }\n          };\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      });\n      return listener;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(listener) {\n        var callback, _callback2, eventName, listeners;\n        return _regeneratorRuntime().wrap(function _callee25$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              // Get the callback.\n              callback = this._eventCallbacks.get(listener);\n              if (callback) {\n                _context29.next = 3;\n                break;\n              }\n              throw new Error(\"Event listener \".concat(listener, \" doesn't exist!\"));\n            case 3:\n              _callback2 = _slicedToArray(callback, 1), eventName = _callback2[0]; // Get the listeners.\n              listeners = this._eventListeners.get(eventName);\n              if (listeners) {\n                _context29.next = 7;\n                break;\n              }\n              throw new Error(\"Event listeners don't exist for \".concat(eventName, \"!\"));\n            case 7:\n              // Update both maps.\n              this._eventCallbacks.delete(listener);\n              listeners = listeners.filter(function (l) {\n                return l !== listener;\n              });\n              this._eventListeners.set(eventName, listeners);\n              if (listeners.length === 0) {\n                this._eventListeners.delete(eventName);\n              }\n              // Kill the websocket connection if all listeners have been removed.\n              if (!(this._eventCallbacks.size == 0)) {\n                _context29.next = 17;\n                break;\n              }\n              assert$1.ok(this._eventListeners.size === 0);\n              if (!(this._onLogsSubscriptionId !== undefined)) {\n                _context29.next = 17;\n                break;\n              }\n              _context29.next = 16;\n              return this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n            case 16:\n              this._onLogsSubscriptionId = undefined;\n            case 17:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee25, this);\n      }));\n      function removeEventListener(_x65) {\n        return _removeEventListener.apply(this, arguments);\n      }\n      return removeEventListener;\n    }()\n  }]);\n  return EventManager;\n}();\nvar EventParser = /*#__PURE__*/function () {\n  function EventParser(programId, coder) {\n    _classCallCheck(this, EventParser);\n    this.coder = coder;\n    this.programId = programId;\n  }\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  _createClass(EventParser, [{\n    key: \"parseLogs\",\n    value: function parseLogs(logs) {\n      var _this26 = this;\n      var errorOnDecodeFailure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        var logScanner, execution, log, _this26$handleLog, _this26$handleLog2, event, newProgram, didPop;\n        return _regeneratorRuntime().wrap(function _callee26$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              logScanner = new LogScanner(logs);\n              execution = new ExecutionContext();\n              log = logScanner.next();\n            case 3:\n              if (!(log !== null)) {\n                _context30.next = 13;\n                break;\n              }\n              _this26$handleLog = _this26.handleLog(execution, log, errorOnDecodeFailure), _this26$handleLog2 = _slicedToArray(_this26$handleLog, 3), event = _this26$handleLog2[0], newProgram = _this26$handleLog2[1], didPop = _this26$handleLog2[2];\n              if (!event) {\n                _context30.next = 8;\n                break;\n              }\n              _context30.next = 8;\n              return event;\n            case 8:\n              if (newProgram) {\n                execution.push(newProgram);\n              }\n              if (didPop) {\n                execution.pop();\n              }\n              log = logScanner.next();\n              _context30.next = 3;\n              break;\n            case 13:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee26);\n      })();\n    } // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n  }, {\n    key: \"handleLog\",\n    value: function handleLog(execution, log, errorOnDecodeFailure) {\n      // Executing program is this program.\n      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n        return this.handleProgramLog(log, errorOnDecodeFailure);\n      }\n      // Executing program is not this program.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs from *this* program.\n  }, {\n    key: \"handleProgramLog\",\n    value: function handleProgramLog(log, errorOnDecodeFailure) {\n      // This is a `msg!` log or a `sol_log_data` log.\n      if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {\n        var logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);\n        var event = this.coder.events.decode(logStr);\n        if (errorOnDecodeFailure && event === null) {\n          throw new Error(\"Unable to decode event \".concat(logStr));\n        }\n        return [event, null, false];\n      }\n      // System log.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs when the current program being executing is *not* this.\n  }, {\n    key: \"handleSystemLog\",\n    value: function handleSystemLog(log) {\n      // System component.\n      var logStart = log.split(\":\")[0];\n      // Did the program finish executing?\n      if (logStart.match(/^Program (.*) success/g) !== null) {\n        return [null, true];\n        // Recursive call.\n      } else if (logStart.startsWith(\"Program \".concat(this.programId.toString(), \" invoke\"))) {\n        return [this.programId.toString(), false];\n      }\n      // CPI call.\n      else if (logStart.includes(\"invoke\")) {\n        return [\"cpi\", false]; // Any string will do.\n      } else {\n        return [null, false];\n      }\n    }\n  }]);\n  return EventParser;\n}(); // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nvar ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext() {\n    _classCallCheck(this, ExecutionContext);\n    this.stack = [];\n  }\n  _createClass(ExecutionContext, [{\n    key: \"program\",\n    value: function program() {\n      assert$1.ok(this.stack.length > 0);\n      return this.stack[this.stack.length - 1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(newProgram) {\n      this.stack.push(newProgram);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert$1.ok(this.stack.length > 0);\n      this.stack.pop();\n    }\n  }]);\n  return ExecutionContext;\n}();\nvar LogScanner = /*#__PURE__*/function () {\n  function LogScanner(logs) {\n    _classCallCheck(this, LogScanner);\n    this.logs = logs;\n  }\n  _createClass(LogScanner, [{\n    key: \"next\",\n    value: function next() {\n      if (this.logs.length === 0) {\n        return null;\n      }\n      var l = this.logs[0];\n      this.logs = this.logs.slice(1);\n      return l;\n    }\n  }]);\n  return LogScanner;\n}();\nvar SimulateFactory = /*#__PURE__*/function () {\n  function SimulateFactory() {\n    _classCallCheck(this, SimulateFactory);\n  }\n  _createClass(SimulateFactory, null, [{\n    key: \"build\",\n    value: function build(idlIx, txFn, idlErrors, provider, coder, programId, idl) {\n      var simulate = /*#__PURE__*/function () {\n        var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n          var _a,\n            _len7,\n            args,\n            _key7,\n            tx,\n            _splitArgsAndCtx7,\n            _splitArgsAndCtx8,\n            ctx,\n            resp,\n            logs,\n            events,\n            parser,\n            _iterator17,\n            _step17,\n            event,\n            _args32 = arguments;\n          return _regeneratorRuntime().wrap(function _callee27$(_context31) {\n            while (1) switch (_context31.prev = _context31.next) {\n              case 0:\n                for (_len7 = _args32.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n                  args[_key7] = _args32[_key7];\n                }\n                tx = txFn.apply(void 0, args);\n                _splitArgsAndCtx7 = splitArgsAndCtx(idlIx, [].concat(args)), _splitArgsAndCtx8 = _slicedToArray(_splitArgsAndCtx7, 2), ctx = _splitArgsAndCtx8[1];\n                resp = undefined;\n                if (!(provider.simulate === undefined)) {\n                  _context31.next = 6;\n                  break;\n                }\n                throw new Error(\"This function requires 'Provider.simulate' to be implemented.\");\n              case 6:\n                _context31.prev = 6;\n                _context31.next = 9;\n                return provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === void 0 ? void 0 : _a.commitment);\n              case 9:\n                resp = _context31.sent;\n                _context31.next = 15;\n                break;\n              case 12:\n                _context31.prev = 12;\n                _context31.t0 = _context31[\"catch\"](6);\n                throw translateError(_context31.t0, idlErrors);\n              case 15:\n                if (!(resp === undefined)) {\n                  _context31.next = 17;\n                  break;\n                }\n                throw new Error(\"Unable to simulate transaction\");\n              case 17:\n                logs = resp.logs;\n                if (logs) {\n                  _context31.next = 20;\n                  break;\n                }\n                throw new Error(\"Simulated logs not found\");\n              case 20:\n                events = [];\n                if (idl.events) {\n                  parser = new EventParser(programId, coder);\n                  _iterator17 = _createForOfIteratorHelper(parser.parseLogs(logs));\n                  try {\n                    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                      event = _step17.value;\n                      events.push(event);\n                    }\n                  } catch (err) {\n                    _iterator17.e(err);\n                  } finally {\n                    _iterator17.f();\n                  }\n                }\n                return _context31.abrupt(\"return\", {\n                  events: events,\n                  raw: logs\n                });\n              case 23:\n              case \"end\":\n                return _context31.stop();\n            }\n          }, _callee27, null, [[6, 12]]);\n        }));\n        return function simulate() {\n          return _ref19.apply(this, arguments);\n        };\n      }();\n      return simulate;\n    }\n  }]);\n  return SimulateFactory;\n}();\nfunction uint64(property) {\n  return new WrappedLayout(blob(8), function (b) {\n    return u64.fromBuffer(b);\n  }, function (n) {\n    return n.toBuffer();\n  }, property);\n}\nfunction publicKey(property) {\n  return new WrappedLayout(blob(32), function (b) {\n    return new PublicKey(b);\n  }, function (key) {\n    return key.toBuffer();\n  }, property);\n}\nfunction coption(layout, property) {\n  return new COptionLayout(layout, property);\n}\nvar WrappedLayout = /*#__PURE__*/function (_Layout_3) {\n  _inherits(WrappedLayout, _Layout_3);\n  function WrappedLayout(layout, decoder, encoder, property) {\n    var _this27;\n    _classCallCheck(this, WrappedLayout);\n    _this27 = _possibleConstructorReturn(this, _getPrototypeOf(WrappedLayout).call(this, layout.span, property));\n    _this27.layout = layout;\n    _this27.decoder = decoder;\n    _this27.encoder = encoder;\n    return _this27;\n  }\n  _createClass(WrappedLayout, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      return this.decoder(this.layout.decode(b, offset));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      return this.layout.encode(this.encoder(src), b, offset);\n    }\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      return this.layout.getSpan(b, offset);\n    }\n  }]);\n  return WrappedLayout;\n}(Layout_2);\nvar COptionLayout = /*#__PURE__*/function (_Layout_4) {\n  _inherits(COptionLayout, _Layout_4);\n  function COptionLayout(layout, property) {\n    var _this28;\n    _classCallCheck(this, COptionLayout);\n    _this28 = _possibleConstructorReturn(this, _getPrototypeOf(COptionLayout).call(this, -1, property));\n    _this28.layout = layout;\n    _this28.discriminator = u32();\n    return _this28;\n  }\n  _createClass(COptionLayout, [{\n    key: \"encode\",\n    value: function encode(src, b) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (src === null || src === undefined) {\n        return this.layout.span + this.discriminator.encode(0, b, offset);\n      }\n      this.discriminator.encode(1, b, offset);\n      return this.layout.encode(src, b, offset + 4) + 4;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(b) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var discriminator = this.discriminator.decode(b, offset);\n      if (discriminator === 0) {\n        return null;\n      } else if (discriminator === 1) {\n        return this.layout.decode(b, offset + 4);\n      }\n      throw new Error(\"Invalid coption \" + this.layout.property);\n    }\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(b) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.layout.getSpan(b, offset + 4) + 4;\n    }\n  }]);\n  return COptionLayout;\n}(Layout_2);\nvar u64 = /*#__PURE__*/function (_BN) {\n  _inherits(u64, _BN);\n  function u64() {\n    _classCallCheck(this, u64);\n    return _possibleConstructorReturn(this, _getPrototypeOf(u64).apply(this, arguments));\n  }\n  _createClass(u64, [{\n    key: \"toBuffer\",\n    /**\n     * Convert to Buffer representation\n     */\n    value: function toBuffer() {\n      var a = _get(_getPrototypeOf(u64.prototype), \"toArray\", this).call(this).reverse();\n      var b = Buffer.from(a);\n      if (b.length === 8) {\n        return b;\n      }\n      if (b.length >= 8) {\n        throw new Error(\"u64 too large\");\n      }\n      var zeroPad = Buffer.alloc(8);\n      b.copy(zeroPad);\n      return zeroPad;\n    }\n    /**\n     * Construct a u64 from Buffer representation\n     */\n  }], [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer) {\n      if (buffer.length !== 8) {\n        throw new Error(\"Invalid buffer length: \".concat(buffer.length));\n      }\n      return new u64(_toConsumableArray(buffer).reverse().map(function (i) {\n        return \"00\".concat(i.toString(16)).slice(-2);\n      }).join(\"\"), 16);\n    }\n  }]);\n  return u64;\n}(BN);\nvar TOKEN_ACCOUNT_LAYOUT = struct([publicKey(\"mint\"), publicKey(\"owner\"), uint64(\"amount\"), coption(publicKey(), \"delegate\"), function (p) {\n  var U = union(u8(\"discriminator\"), null, p);\n  U.addVariant(0, struct([]), \"uninitialized\");\n  U.addVariant(1, struct([]), \"initialized\");\n  U.addVariant(2, struct([]), \"frozen\");\n  return U;\n}(\"state\"), coption(uint64(), \"isNative\"), uint64(\"delegatedAmount\"), coption(publicKey(), \"closeAuthority\")]);\nfunction decodeTokenAccount(b) {\n  return TOKEN_ACCOUNT_LAYOUT.decode(b);\n}\n\n// Populates a given accounts context with PDAs and common missing accounts.\nvar AccountsResolver = /*#__PURE__*/function () {\n  function AccountsResolver(_args, _accounts, _provider, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {\n    _classCallCheck(this, AccountsResolver);\n    this._accounts = _accounts;\n    this._provider = _provider;\n    this._programId = _programId;\n    this._idlIx = _idlIx;\n    this._idlTypes = _idlTypes;\n    this._customResolver = _customResolver;\n    this._args = _args;\n    this._accountStore = new AccountStore(_provider, _accountNamespace, this._programId);\n  }\n  _createClass(AccountsResolver, [{\n    key: \"args\",\n    value: function args(_args) {\n      this._args = _args;\n    } // Note: We serially resolve PDAs one by one rather than doing them\n    //       in parallel because there can be dependencies between\n    //       addresses. That is, one PDA can be used as a seed in another.\n  }, {\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        return _regeneratorRuntime().wrap(function _callee28$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              _context32.next = 2;\n              return this.resolveConst(this._idlIx.accounts);\n            case 2:\n              _context32.next = 4;\n              return this.resolvePdas(this._idlIx.accounts);\n            case 4:\n              _context32.t0 = _context32.sent;\n              _context32.next = 7;\n              return this.resolveRelations(this._idlIx.accounts);\n            case 7:\n              _context32.t1 = _context32.sent;\n              _context32.t2 = _context32.t0 + _context32.t1;\n              _context32.next = 11;\n              return this.resolveCustom();\n            case 11:\n              _context32.t3 = _context32.sent;\n              _context32.t4 = _context32.t2 + _context32.t3;\n              if (!(_context32.t4 > 0)) {\n                _context32.next = 16;\n                break;\n              }\n              _context32.next = 2;\n              break;\n            case 16:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee28, this);\n      }));\n      function resolve() {\n        return _resolve.apply(this, arguments);\n      }\n      return resolve;\n    }()\n  }, {\n    key: \"resolveCustom\",\n    value: function () {\n      var _resolveCustom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var _yield$this$_customRe, accounts, resolved;\n        return _regeneratorRuntime().wrap(function _callee29$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              if (!this._customResolver) {\n                _context33.next = 8;\n                break;\n              }\n              _context33.next = 3;\n              return this._customResolver({\n                args: this._args,\n                accounts: this._accounts,\n                provider: this._provider,\n                programId: this._programId,\n                idlIx: this._idlIx\n              });\n            case 3:\n              _yield$this$_customRe = _context33.sent;\n              accounts = _yield$this$_customRe.accounts;\n              resolved = _yield$this$_customRe.resolved;\n              this._accounts = accounts;\n              return _context33.abrupt(\"return\", resolved);\n            case 8:\n              return _context33.abrupt(\"return\", 0);\n            case 9:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee29, this);\n      }));\n      function resolveCustom() {\n        return _resolveCustom.apply(this, arguments);\n      }\n      return resolveCustom;\n    }()\n  }, {\n    key: \"resolveOptionalsHelper\",\n    value: function resolveOptionalsHelper(partialAccounts, accountItems) {\n      var nestedAccountsGeneric = {};\n      // Looping through accountItem array instead of on partialAccounts, so\n      // we only traverse array once\n      var _iterator18 = _createForOfIteratorHelper(accountItems),\n        _step18;\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var accountItem = _step18.value;\n          var accountName = accountItem.name;\n          var partialAccount = partialAccounts[accountName];\n          // Skip if the account isn't included (thus would be undefined)\n          if (partialAccount === undefined) continue;\n          if (isPartialAccounts(partialAccount)) {\n            // is compound accounts, recurse one level deeper\n            if (isIdlAccounts(accountItem)) {\n              nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem[\"accounts\"]);\n            } else {\n              // Here we try our best to recover gracefully. If there are optionals we can't check, we will fail then.\n              nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);\n            }\n          } else {\n            // if not compound accounts, do null/optional check and proceed\n            if (partialAccount !== null) {\n              nestedAccountsGeneric[accountName] = translateAddress(partialAccount);\n            } else if (accountItem[\"isOptional\"]) {\n              nestedAccountsGeneric[accountName] = this._programId;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      return nestedAccountsGeneric;\n    }\n  }, {\n    key: \"resolveOptionals\",\n    value: function resolveOptionals(accounts) {\n      Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));\n    }\n  }, {\n    key: \"get\",\n    value: function get(path) {\n      // Only return if pubkey\n      var ret = path.reduce(function (acc, subPath) {\n        return acc && acc[subPath];\n      }, this._accounts);\n      if (ret && ret.toBase58) {\n        return ret;\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(path, value) {\n      var curr = this._accounts;\n      path.forEach(function (p, idx) {\n        var isLast = idx == path.length - 1;\n        if (isLast) {\n          curr[p] = value;\n        }\n        curr[p] = curr[p] || {};\n        curr = curr[p];\n      });\n    }\n  }, {\n    key: \"resolveConst\",\n    value: function () {\n      var _resolveConst = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(accounts) {\n        var path,\n          k,\n          accountDescOrAccounts,\n          subAccounts,\n          accountDesc,\n          accountDescName,\n          _args35 = arguments;\n        return _regeneratorRuntime().wrap(function _callee30$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              path = _args35.length > 1 && _args35[1] !== undefined ? _args35[1] : [];\n              k = 0;\n            case 2:\n              if (!(k < accounts.length)) {\n                _context34.next = 18;\n                break;\n              }\n              accountDescOrAccounts = accounts[k];\n              subAccounts = accountDescOrAccounts.accounts;\n              if (!subAccounts) {\n                _context34.next = 8;\n                break;\n              }\n              _context34.next = 8;\n              return this.resolveConst(subAccounts, [].concat(_toConsumableArray(path), [camelCase(accountDescOrAccounts.name)]));\n            case 8:\n              accountDesc = accountDescOrAccounts;\n              accountDescName = camelCase(accountDescOrAccounts.name); // Signers default to the provider.\n              if (!(accountDesc.isSigner && !this.get([].concat(_toConsumableArray(path), [accountDescName])))) {\n                _context34.next = 14;\n                break;\n              }\n              if (!(this._provider.wallet === undefined)) {\n                _context34.next = 13;\n                break;\n              }\n              throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n            case 13:\n              // @ts-expect-error\n              this.set([].concat(_toConsumableArray(path), [accountDescName]), this._provider.wallet.publicKey);\n            case 14:\n              // Common accounts are auto populated with magic names by convention.\n              if (Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this.get([].concat(_toConsumableArray(path), [accountDescName]))) {\n                this.set([].concat(_toConsumableArray(path), [accountDescName]), AccountsResolver.CONST_ACCOUNTS[accountDescName]);\n              }\n            case 15:\n              k += 1;\n              _context34.next = 2;\n              break;\n            case 18:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee30, this);\n      }));\n      function resolveConst(_x66) {\n        return _resolveConst.apply(this, arguments);\n      }\n      return resolveConst;\n    }()\n  }, {\n    key: \"resolvePdas\",\n    value: function () {\n      var _resolvePdas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(accounts) {\n        var path,\n          found,\n          k,\n          accountDesc,\n          subAccounts,\n          accountDescCasted,\n          accountDescName,\n          _args36 = arguments;\n        return _regeneratorRuntime().wrap(function _callee31$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              path = _args36.length > 1 && _args36[1] !== undefined ? _args36[1] : [];\n              found = 0;\n              k = 0;\n            case 3:\n              if (!(k < accounts.length)) {\n                _context35.next = 23;\n                break;\n              }\n              accountDesc = accounts[k];\n              subAccounts = accountDesc.accounts;\n              if (!subAccounts) {\n                _context35.next = 11;\n                break;\n              }\n              _context35.t0 = found;\n              _context35.next = 10;\n              return this.resolvePdas(subAccounts, [].concat(_toConsumableArray(path), [camelCase(accountDesc.name)]));\n            case 10:\n              found = _context35.t0 += _context35.sent;\n            case 11:\n              accountDescCasted = accountDesc;\n              accountDescName = camelCase(accountDesc.name); // PDA derived from IDL seeds.\n              if (!(accountDescCasted.pda && accountDescCasted.pda.seeds.length > 0 && !this.get([].concat(_toConsumableArray(path), [accountDescName])))) {\n                _context35.next = 20;\n                break;\n              }\n              _context35.t1 = Boolean;\n              _context35.next = 17;\n              return this.autoPopulatePda(accountDescCasted, path);\n            case 17:\n              _context35.t2 = _context35.sent;\n              if (!(0, _context35.t1)(_context35.t2)) {\n                _context35.next = 20;\n                break;\n              }\n              found += 1;\n            case 20:\n              k += 1;\n              _context35.next = 3;\n              break;\n            case 23:\n              return _context35.abrupt(\"return\", found);\n            case 24:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee31, this);\n      }));\n      function resolvePdas(_x67) {\n        return _resolvePdas.apply(this, arguments);\n      }\n      return resolvePdas;\n    }()\n  }, {\n    key: \"resolveRelations\",\n    value: function () {\n      var _resolveRelations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(accounts) {\n        var _this29 = this;\n        var path,\n          found,\n          _loop2,\n          k,\n          _args39 = arguments;\n        return _regeneratorRuntime().wrap(function _callee33$(_context38) {\n          while (1) switch (_context38.prev = _context38.next) {\n            case 0:\n              path = _args39.length > 1 && _args39[1] !== undefined ? _args39[1] : [];\n              found = 0;\n              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n                var accountDesc, subAccounts, relations, accountDescName, newPath, accountKey, matching, account;\n                return _regeneratorRuntime().wrap(function _loop2$(_context37) {\n                  while (1) switch (_context37.prev = _context37.next) {\n                    case 0:\n                      accountDesc = accounts[k];\n                      subAccounts = accountDesc.accounts;\n                      if (!subAccounts) {\n                        _context37.next = 7;\n                        break;\n                      }\n                      _context37.t0 = found;\n                      _context37.next = 6;\n                      return _this29.resolveRelations(subAccounts, [].concat(_toConsumableArray(path), [camelCase(accountDesc.name)]));\n                    case 6:\n                      found = _context37.t0 += _context37.sent;\n                    case 7:\n                      relations = accountDesc.relations || [];\n                      accountDescName = camelCase(accountDesc.name);\n                      newPath = [].concat(_toConsumableArray(path), [accountDescName]); // If we have this account and there's some missing accounts that are relations to this account, fetch them\n                      accountKey = _this29.get(newPath);\n                      if (!accountKey) {\n                        _context37.next = 20;\n                        break;\n                      }\n                      matching = relations.filter(function (rel) {\n                        return !_this29.get([].concat(_toConsumableArray(path), [camelCase(rel)]));\n                      });\n                      found += matching.length;\n                      if (!(matching.length > 0)) {\n                        _context37.next = 20;\n                        break;\n                      }\n                      _context37.next = 17;\n                      return _this29._accountStore.fetchAccount({\n                        publicKey: accountKey\n                      });\n                    case 17:\n                      account = _context37.sent;\n                      _context37.next = 20;\n                      return Promise.all(matching.map( /*#__PURE__*/function () {\n                        var _ref20 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(rel) {\n                          var relName;\n                          return _regeneratorRuntime().wrap(function _callee32$(_context36) {\n                            while (1) switch (_context36.prev = _context36.next) {\n                              case 0:\n                                relName = camelCase(rel);\n                                _this29.set([].concat(_toConsumableArray(path), [relName]), account[relName]);\n                                return _context36.abrupt(\"return\", account[relName]);\n                              case 3:\n                              case \"end\":\n                                return _context36.stop();\n                            }\n                          }, _callee32);\n                        }));\n                        return function (_x69) {\n                          return _ref20.apply(this, arguments);\n                        };\n                      }()));\n                    case 20:\n                    case \"end\":\n                      return _context37.stop();\n                  }\n                }, _loop2);\n              });\n              k = 0;\n            case 4:\n              if (!(k < accounts.length)) {\n                _context38.next = 9;\n                break;\n              }\n              return _context38.delegateYield(_loop2(), \"t0\", 6);\n            case 6:\n              k += 1;\n              _context38.next = 4;\n              break;\n            case 9:\n              return _context38.abrupt(\"return\", found);\n            case 10:\n            case \"end\":\n              return _context38.stop();\n          }\n        }, _callee33);\n      }));\n      function resolveRelations(_x68) {\n        return _resolveRelations.apply(this, arguments);\n      }\n      return resolveRelations;\n    }()\n  }, {\n    key: \"autoPopulatePda\",\n    value: function () {\n      var _autoPopulatePda = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(accountDesc) {\n        var _this30 = this;\n        var path,\n          seeds,\n          programId,\n          _yield$PublicKey$find,\n          _yield$PublicKey$find2,\n          pubkey,\n          _args40 = arguments;\n        return _regeneratorRuntime().wrap(function _callee34$(_context39) {\n          while (1) switch (_context39.prev = _context39.next) {\n            case 0:\n              path = _args40.length > 1 && _args40[1] !== undefined ? _args40[1] : [];\n              if (!(!accountDesc.pda || !accountDesc.pda.seeds)) {\n                _context39.next = 3;\n                break;\n              }\n              throw new Error(\"Must have seeds\");\n            case 3:\n              _context39.next = 5;\n              return Promise.all(accountDesc.pda.seeds.map(function (seedDesc) {\n                return _this30.toBuffer(seedDesc, path);\n              }));\n            case 5:\n              seeds = _context39.sent;\n              if (!seeds.some(function (seed) {\n                return typeof seed == \"undefined\";\n              })) {\n                _context39.next = 8;\n                break;\n              }\n              return _context39.abrupt(\"return\");\n            case 8:\n              _context39.next = 10;\n              return this.parseProgramId(accountDesc, path);\n            case 10:\n              programId = _context39.sent;\n              if (programId) {\n                _context39.next = 13;\n                break;\n              }\n              return _context39.abrupt(\"return\");\n            case 13:\n              _context39.next = 15;\n              return PublicKey.findProgramAddress(seeds, programId);\n            case 15:\n              _yield$PublicKey$find = _context39.sent;\n              _yield$PublicKey$find2 = _slicedToArray(_yield$PublicKey$find, 1);\n              pubkey = _yield$PublicKey$find2[0];\n              this.set([].concat(_toConsumableArray(path), [camelCase(accountDesc.name)]), pubkey);\n            case 19:\n            case \"end\":\n              return _context39.stop();\n          }\n        }, _callee34, this);\n      }));\n      function autoPopulatePda(_x70) {\n        return _autoPopulatePda.apply(this, arguments);\n      }\n      return autoPopulatePda;\n    }()\n  }, {\n    key: \"parseProgramId\",\n    value: function () {\n      var _parseProgramId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(accountDesc) {\n        var path,\n          _a,\n          _args41 = arguments;\n        return _regeneratorRuntime().wrap(function _callee35$(_context40) {\n          while (1) switch (_context40.prev = _context40.next) {\n            case 0:\n              path = _args41.length > 1 && _args41[1] !== undefined ? _args41[1] : [];\n              if ((_a = accountDesc.pda) === null || _a === void 0 ? void 0 : _a.programId) {\n                _context40.next = 3;\n                break;\n              }\n              return _context40.abrupt(\"return\", this._programId);\n            case 3:\n              _context40.t0 = accountDesc.pda.programId.kind;\n              _context40.next = _context40.t0 === \"const\" ? 6 : _context40.t0 === \"arg\" ? 7 : _context40.t0 === \"account\" ? 8 : 11;\n              break;\n            case 6:\n              return _context40.abrupt(\"return\", new PublicKey(this.toBufferConst(accountDesc.pda.programId.value)));\n            case 7:\n              return _context40.abrupt(\"return\", this.argValue(accountDesc.pda.programId));\n            case 8:\n              _context40.next = 10;\n              return this.accountValue(accountDesc.pda.programId, path);\n            case 10:\n              return _context40.abrupt(\"return\", _context40.sent);\n            case 11:\n              throw new Error(\"Unexpected program seed kind: \".concat(accountDesc.pda.programId.kind));\n            case 12:\n            case \"end\":\n              return _context40.stop();\n          }\n        }, _callee35, this);\n      }));\n      function parseProgramId(_x71) {\n        return _parseProgramId.apply(this, arguments);\n      }\n      return parseProgramId;\n    }()\n  }, {\n    key: \"toBuffer\",\n    value: function () {\n      var _toBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(seedDesc) {\n        var path,\n          _args42 = arguments;\n        return _regeneratorRuntime().wrap(function _callee36$(_context41) {\n          while (1) switch (_context41.prev = _context41.next) {\n            case 0:\n              path = _args42.length > 1 && _args42[1] !== undefined ? _args42[1] : [];\n              _context41.t0 = seedDesc.kind;\n              _context41.next = _context41.t0 === \"const\" ? 4 : _context41.t0 === \"arg\" ? 5 : _context41.t0 === \"account\" ? 8 : 11;\n              break;\n            case 4:\n              return _context41.abrupt(\"return\", this.toBufferConst(seedDesc));\n            case 5:\n              _context41.next = 7;\n              return this.toBufferArg(seedDesc);\n            case 7:\n              return _context41.abrupt(\"return\", _context41.sent);\n            case 8:\n              _context41.next = 10;\n              return this.toBufferAccount(seedDesc, path);\n            case 10:\n              return _context41.abrupt(\"return\", _context41.sent);\n            case 11:\n              throw new Error(\"Unexpected seed kind: \".concat(seedDesc.kind));\n            case 12:\n            case \"end\":\n              return _context41.stop();\n          }\n        }, _callee36, this);\n      }));\n      function toBuffer(_x72) {\n        return _toBuffer.apply(this, arguments);\n      }\n      return toBuffer;\n    }()\n    /**\n     * Recursively get the type at some path of either a primitive or a user defined struct.\n     */\n  }, {\n    key: \"getType\",\n    value: function getType(type) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      if (path.length > 0 && type.defined) {\n        var subType = this._idlTypes.find(function (t) {\n          return t.name === type.defined;\n        });\n        if (!subType) {\n          throw new Error(\"Cannot find type \".concat(type.defined));\n        }\n        var structType = subType.type; // enum not supported yet\n        var field = structType.fields.find(function (field) {\n          return field.name === path[0];\n        });\n        return this.getType(field.type, path.slice(1));\n      }\n      return type;\n    }\n  }, {\n    key: \"toBufferConst\",\n    value: function toBufferConst(seedDesc) {\n      return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || \"\").split(\".\").slice(1)), seedDesc.value);\n    }\n  }, {\n    key: \"toBufferArg\",\n    value: function () {\n      var _toBufferArg = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(seedDesc) {\n        var argValue;\n        return _regeneratorRuntime().wrap(function _callee37$(_context42) {\n          while (1) switch (_context42.prev = _context42.next) {\n            case 0:\n              argValue = this.argValue(seedDesc);\n              if (!(typeof argValue === \"undefined\")) {\n                _context42.next = 3;\n                break;\n              }\n              return _context42.abrupt(\"return\");\n            case 3:\n              return _context42.abrupt(\"return\", this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || \"\").split(\".\").slice(1)), argValue));\n            case 4:\n            case \"end\":\n              return _context42.stop();\n          }\n        }, _callee37, this);\n      }));\n      function toBufferArg(_x73) {\n        return _toBufferArg.apply(this, arguments);\n      }\n      return toBufferArg;\n    }()\n  }, {\n    key: \"argValue\",\n    value: function argValue(seedDesc) {\n      var split = seedDesc.path.split(\".\");\n      var seedArgName = camelCase(split[0]);\n      var idlArgPosition = this._idlIx.args.findIndex(function (argDesc) {\n        return argDesc.name === seedArgName;\n      });\n      if (idlArgPosition === -1) {\n        throw new Error(\"Unable to find argument for seed: \".concat(seedArgName));\n      }\n      return split.slice(1).reduce(function (curr, path) {\n        return (curr || {})[path];\n      }, this._args[idlArgPosition]);\n    }\n  }, {\n    key: \"toBufferAccount\",\n    value: function () {\n      var _toBufferAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(seedDesc) {\n        var path,\n          accountValue,\n          _args44 = arguments;\n        return _regeneratorRuntime().wrap(function _callee38$(_context43) {\n          while (1) switch (_context43.prev = _context43.next) {\n            case 0:\n              path = _args44.length > 1 && _args44[1] !== undefined ? _args44[1] : [];\n              _context43.next = 3;\n              return this.accountValue(seedDesc, path);\n            case 3:\n              accountValue = _context43.sent;\n              if (accountValue) {\n                _context43.next = 6;\n                break;\n              }\n              return _context43.abrupt(\"return\");\n            case 6:\n              return _context43.abrupt(\"return\", this.toBufferValue(seedDesc.type, accountValue));\n            case 7:\n            case \"end\":\n              return _context43.stop();\n          }\n        }, _callee38, this);\n      }));\n      function toBufferAccount(_x74) {\n        return _toBufferAccount.apply(this, arguments);\n      }\n      return toBufferAccount;\n    }()\n  }, {\n    key: \"accountValue\",\n    value: function () {\n      var _accountValue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(seedDesc) {\n        var path,\n          pathComponents,\n          fieldName,\n          fieldPubkey,\n          account,\n          fieldValue,\n          _args45 = arguments;\n        return _regeneratorRuntime().wrap(function _callee39$(_context44) {\n          while (1) switch (_context44.prev = _context44.next) {\n            case 0:\n              path = _args45.length > 1 && _args45[1] !== undefined ? _args45[1] : [];\n              pathComponents = seedDesc.path.split(\".\");\n              fieldName = pathComponents[0];\n              fieldPubkey = this.get([].concat(_toConsumableArray(path), [camelCase(fieldName)]));\n              if (!(fieldPubkey === null)) {\n                _context44.next = 6;\n                break;\n              }\n              throw new Error(\"fieldPubkey is null\");\n            case 6:\n              if (!(pathComponents.length === 1)) {\n                _context44.next = 8;\n                break;\n              }\n              return _context44.abrupt(\"return\", fieldPubkey);\n            case 8:\n              _context44.next = 10;\n              return this._accountStore.fetchAccount({\n                publicKey: fieldPubkey,\n                name: seedDesc.account\n              });\n            case 10:\n              account = _context44.sent;\n              // Dereference all fields in the path to get the field value\n              // used in the seed.\n              fieldValue = this.parseAccountValue(account, pathComponents.slice(1));\n              return _context44.abrupt(\"return\", fieldValue);\n            case 13:\n            case \"end\":\n              return _context44.stop();\n          }\n        }, _callee39, this);\n      }));\n      function accountValue(_x75) {\n        return _accountValue.apply(this, arguments);\n      }\n      return accountValue;\n    }()\n  }, {\n    key: \"parseAccountValue\",\n    value: function parseAccountValue(account, path) {\n      var accountField;\n      while (path.length > 0) {\n        accountField = account[camelCase(path[0])];\n        path = path.slice(1);\n      }\n      return accountField;\n    } // Converts the given idl valaue into a Buffer. The values here must be\n    // primitives. E.g. no structs.\n    //\n    // TODO: add more types here as needed.\n  }, {\n    key: \"toBufferValue\",\n    value: function toBufferValue(type, value) {\n      switch (type) {\n        case \"u8\":\n          return Buffer.from([value]);\n        case \"u16\":\n          var b = Buffer.alloc(2);\n          b.writeUInt16LE(value);\n          return b;\n        case \"u32\":\n          var buf = Buffer.alloc(4);\n          buf.writeUInt32LE(value);\n          return buf;\n        case \"u64\":\n          var bU64 = Buffer.alloc(8);\n          bU64.writeBigUInt64LE(BigInt(value));\n          return bU64;\n        case \"string\":\n          return Buffer.from(encode$2(value));\n        case \"publicKey\":\n          return value.toBuffer();\n        default:\n          if (type.array) {\n            return Buffer.from(value);\n          }\n          throw new Error(\"Unexpected seed type: \".concat(type));\n      }\n    }\n  }]);\n  return AccountsResolver;\n}();\nAccountsResolver.CONST_ACCOUNTS = {\n  associatedTokenProgram: ASSOCIATED_PROGRAM_ID,\n  rent: SYSVAR_RENT_PUBKEY,\n  systemProgram: SystemProgram.programId,\n  tokenProgram: TOKEN_PROGRAM_ID,\n  clock: SYSVAR_CLOCK_PUBKEY\n};\n// TODO: this should be configureable to avoid unnecessary requests.\nvar AccountStore = /*#__PURE__*/function () {\n  // todo: don't use the progrma use the account namespace.\n  function AccountStore(_provider, _accounts, _programId) {\n    _classCallCheck(this, AccountStore);\n    this._provider = _provider;\n    this._programId = _programId;\n    this._cache = new Map();\n    this._idls = {};\n    this._idls[_programId.toBase58()] = _accounts;\n  }\n  _createClass(AccountStore, [{\n    key: \"ensureIdl\",\n    value: function () {\n      var _ensureIdl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40(programId) {\n        var _idl2, _program;\n        return _regeneratorRuntime().wrap(function _callee40$(_context45) {\n          while (1) switch (_context45.prev = _context45.next) {\n            case 0:\n              if (this._idls[programId.toBase58()]) {\n                _context45.next = 5;\n                break;\n              }\n              _context45.next = 3;\n              return Program.fetchIdl(programId, this._provider);\n            case 3:\n              _idl2 = _context45.sent;\n              if (_idl2) {\n                _program = new Program(_idl2, programId, this._provider);\n                this._idls[programId.toBase58()] = _program.account;\n              }\n            case 5:\n              return _context45.abrupt(\"return\", this._idls[programId.toBase58()]);\n            case 6:\n            case \"end\":\n              return _context45.stop();\n          }\n        }, _callee40, this);\n      }));\n      function ensureIdl(_x76) {\n        return _ensureIdl.apply(this, arguments);\n      }\n      return ensureIdl;\n    }()\n  }, {\n    key: \"fetchAccount\",\n    value: function () {\n      var _fetchAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(_ref21) {\n        var publicKey, name, _ref21$programId, programId, address, accountInfo, data, accounts, accountFetcher, account, _account2, _data, _accounts2, firstAccountLayout, result;\n        return _regeneratorRuntime().wrap(function _callee41$(_context46) {\n          while (1) switch (_context46.prev = _context46.next) {\n            case 0:\n              publicKey = _ref21.publicKey, name = _ref21.name, _ref21$programId = _ref21.programId, programId = _ref21$programId === void 0 ? this._programId : _ref21$programId;\n              address = publicKey.toString();\n              if (this._cache.has(address)) {\n                _context46.next = 41;\n                break;\n              }\n              if (!(name === \"TokenAccount\")) {\n                _context46.next = 13;\n                break;\n              }\n              _context46.next = 6;\n              return this._provider.connection.getAccountInfo(publicKey);\n            case 6:\n              accountInfo = _context46.sent;\n              if (!(accountInfo === null)) {\n                _context46.next = 9;\n                break;\n              }\n              throw new Error(\"invalid account info for \".concat(address));\n            case 9:\n              data = decodeTokenAccount(accountInfo.data);\n              this._cache.set(address, data);\n              _context46.next = 41;\n              break;\n            case 13:\n              if (!name) {\n                _context46.next = 26;\n                break;\n              }\n              _context46.next = 16;\n              return this.ensureIdl(programId);\n            case 16:\n              accounts = _context46.sent;\n              if (!accounts) {\n                _context46.next = 24;\n                break;\n              }\n              accountFetcher = accounts[camelCase(name)];\n              if (!accountFetcher) {\n                _context46.next = 24;\n                break;\n              }\n              _context46.next = 22;\n              return accountFetcher.fetch(publicKey);\n            case 22:\n              account = _context46.sent;\n              this._cache.set(address, account);\n            case 24:\n              _context46.next = 41;\n              break;\n            case 26:\n              _context46.next = 28;\n              return this._provider.connection.getAccountInfo(publicKey);\n            case 28:\n              _account2 = _context46.sent;\n              if (!(_account2 === null)) {\n                _context46.next = 31;\n                break;\n              }\n              throw new Error(\"invalid account info for \".concat(address));\n            case 31:\n              _data = _account2.data;\n              _context46.next = 34;\n              return this.ensureIdl(_account2.owner);\n            case 34:\n              _accounts2 = _context46.sent;\n              if (!_accounts2) {\n                _context46.next = 41;\n                break;\n              }\n              firstAccountLayout = Object.values(_accounts2)[0];\n              if (firstAccountLayout) {\n                _context46.next = 39;\n                break;\n              }\n              throw new Error(\"No accounts for this program\");\n            case 39:\n              result = firstAccountLayout.coder.accounts.decodeAny(_data);\n              this._cache.set(address, result);\n            case 41:\n              return _context46.abrupt(\"return\", this._cache.get(address));\n            case 42:\n            case \"end\":\n              return _context46.stop();\n          }\n        }, _callee41, this);\n      }));\n      function fetchAccount(_x77) {\n        return _fetchAccount.apply(this, arguments);\n      }\n      return fetchAccount;\n    }()\n  }]);\n  return AccountStore;\n}();\nvar MethodsBuilderFactory = /*#__PURE__*/function () {\n  function MethodsBuilderFactory() {\n    _classCallCheck(this, MethodsBuilderFactory);\n  }\n  _createClass(MethodsBuilderFactory, null, [{\n    key: \"build\",\n    value: function build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {\n      return function () {\n        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n          args[_key8] = arguments[_key8];\n        }\n        return new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);\n      };\n    }\n  }]);\n  return MethodsBuilderFactory;\n}();\nfunction isPartialAccounts(partialAccount) {\n  return typeof partialAccount === \"object\" && partialAccount !== null && !(\"_bn\" in partialAccount) // Ensures not a pubkey\n  ;\n}\n\nfunction flattenPartialAccounts(partialAccounts, throwOnNull) {\n  var toReturn = {};\n  for (var accountName in partialAccounts) {\n    var account = partialAccounts[accountName];\n    if (account === null) {\n      if (throwOnNull) throw new Error(\"Failed to resolve optionals due to IDL type mismatch with input accounts!\");\n      continue;\n    }\n    toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : translateAddress(account);\n  }\n  return toReturn;\n}\nvar MethodsBuilder = /*#__PURE__*/function () {\n  function MethodsBuilder(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, _provider, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {\n    _classCallCheck(this, MethodsBuilder);\n    this._ixFn = _ixFn;\n    this._txFn = _txFn;\n    this._rpcFn = _rpcFn;\n    this._simulateFn = _simulateFn;\n    this._viewFn = _viewFn;\n    this._programId = _programId;\n    this._accounts = {};\n    this._remainingAccounts = [];\n    this._signers = [];\n    this._preInstructions = [];\n    this._postInstructions = [];\n    this._autoResolveAccounts = true;\n    this._args = _args;\n    this._accountsResolver = new AccountsResolver(_args, this._accounts, _provider, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver);\n  }\n  _createClass(MethodsBuilder, [{\n    key: \"args\",\n    value: function args(_args) {\n      this._args = _args;\n      this._accountsResolver.args(_args);\n    }\n  }, {\n    key: \"pubkeys\",\n    value: function () {\n      var _pubkeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {\n        return _regeneratorRuntime().wrap(function _callee42$(_context47) {\n          while (1) switch (_context47.prev = _context47.next) {\n            case 0:\n              if (!this._autoResolveAccounts) {\n                _context47.next = 3;\n                break;\n              }\n              _context47.next = 3;\n              return this._accountsResolver.resolve();\n            case 3:\n              return _context47.abrupt(\"return\", this._accounts);\n            case 4:\n            case \"end\":\n              return _context47.stop();\n          }\n        }, _callee42, this);\n      }));\n      function pubkeys() {\n        return _pubkeys.apply(this, arguments);\n      }\n      return pubkeys;\n    }()\n  }, {\n    key: \"accounts\",\n    value: function accounts(_accounts3) {\n      this._autoResolveAccounts = true;\n      this._accountsResolver.resolveOptionals(_accounts3);\n      return this;\n    }\n  }, {\n    key: \"accountsStrict\",\n    value: function accountsStrict(accounts) {\n      this._autoResolveAccounts = false;\n      this._accountsResolver.resolveOptionals(accounts);\n      return this;\n    }\n  }, {\n    key: \"signers\",\n    value: function signers(_signers) {\n      this._signers = this._signers.concat(_signers);\n      return this;\n    }\n  }, {\n    key: \"remainingAccounts\",\n    value: function remainingAccounts(accounts) {\n      this._remainingAccounts = this._remainingAccounts.concat(accounts);\n      return this;\n    }\n  }, {\n    key: \"preInstructions\",\n    value: function preInstructions(ixs) {\n      this._preInstructions = this._preInstructions.concat(ixs);\n      return this;\n    }\n  }, {\n    key: \"postInstructions\",\n    value: function postInstructions(ixs) {\n      this._postInstructions = this._postInstructions.concat(ixs);\n      return this;\n    }\n  }, {\n    key: \"rpc\",\n    value: function () {\n      var _rpc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(options) {\n        return _regeneratorRuntime().wrap(function _callee43$(_context48) {\n          while (1) switch (_context48.prev = _context48.next) {\n            case 0:\n              if (!this._autoResolveAccounts) {\n                _context48.next = 3;\n                break;\n              }\n              _context48.next = 3;\n              return this._accountsResolver.resolve();\n            case 3:\n              return _context48.abrupt(\"return\", this._rpcFn.apply(this, _toConsumableArray(this._args).concat([{\n                accounts: this._accounts,\n                signers: this._signers,\n                remainingAccounts: this._remainingAccounts,\n                preInstructions: this._preInstructions,\n                postInstructions: this._postInstructions,\n                options: options\n              }])));\n            case 4:\n            case \"end\":\n              return _context48.stop();\n          }\n        }, _callee43, this);\n      }));\n      function rpc(_x78) {\n        return _rpc.apply(this, arguments);\n      }\n      return rpc;\n    }()\n  }, {\n    key: \"rpcAndKeys\",\n    value: function () {\n      var _rpcAndKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(options) {\n        var pubkeys;\n        return _regeneratorRuntime().wrap(function _callee44$(_context49) {\n          while (1) switch (_context49.prev = _context49.next) {\n            case 0:\n              _context49.next = 2;\n              return this.pubkeys();\n            case 2:\n              pubkeys = _context49.sent;\n              _context49.t0 = pubkeys;\n              _context49.next = 6;\n              return this.rpc(options);\n            case 6:\n              _context49.t1 = _context49.sent;\n              return _context49.abrupt(\"return\", {\n                pubkeys: _context49.t0,\n                signature: _context49.t1\n              });\n            case 8:\n            case \"end\":\n              return _context49.stop();\n          }\n        }, _callee44, this);\n      }));\n      function rpcAndKeys(_x79) {\n        return _rpcAndKeys.apply(this, arguments);\n      }\n      return rpcAndKeys;\n    }()\n  }, {\n    key: \"view\",\n    value: function () {\n      var _view = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(options) {\n        return _regeneratorRuntime().wrap(function _callee45$(_context50) {\n          while (1) switch (_context50.prev = _context50.next) {\n            case 0:\n              if (!this._autoResolveAccounts) {\n                _context50.next = 3;\n                break;\n              }\n              _context50.next = 3;\n              return this._accountsResolver.resolve();\n            case 3:\n              if (this._viewFn) {\n                _context50.next = 5;\n                break;\n              }\n              throw new Error(\"Method does not support views\");\n            case 5:\n              return _context50.abrupt(\"return\", this._viewFn.apply(this, _toConsumableArray(this._args).concat([{\n                accounts: this._accounts,\n                signers: this._signers,\n                remainingAccounts: this._remainingAccounts,\n                preInstructions: this._preInstructions,\n                postInstructions: this._postInstructions,\n                options: options\n              }])));\n            case 6:\n            case \"end\":\n              return _context50.stop();\n          }\n        }, _callee45, this);\n      }));\n      function view(_x80) {\n        return _view.apply(this, arguments);\n      }\n      return view;\n    }()\n  }, {\n    key: \"simulate\",\n    value: function () {\n      var _simulate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(options) {\n        return _regeneratorRuntime().wrap(function _callee46$(_context51) {\n          while (1) switch (_context51.prev = _context51.next) {\n            case 0:\n              if (!this._autoResolveAccounts) {\n                _context51.next = 3;\n                break;\n              }\n              _context51.next = 3;\n              return this._accountsResolver.resolve();\n            case 3:\n              return _context51.abrupt(\"return\", this._simulateFn.apply(this, _toConsumableArray(this._args).concat([{\n                accounts: this._accounts,\n                signers: this._signers,\n                remainingAccounts: this._remainingAccounts,\n                preInstructions: this._preInstructions,\n                postInstructions: this._postInstructions,\n                options: options\n              }])));\n            case 4:\n            case \"end\":\n              return _context51.stop();\n          }\n        }, _callee46, this);\n      }));\n      function simulate(_x81) {\n        return _simulate2.apply(this, arguments);\n      }\n      return simulate;\n    }()\n  }, {\n    key: \"instruction\",\n    value: function () {\n      var _instruction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47() {\n        return _regeneratorRuntime().wrap(function _callee47$(_context52) {\n          while (1) switch (_context52.prev = _context52.next) {\n            case 0:\n              if (!this._autoResolveAccounts) {\n                _context52.next = 3;\n                break;\n              }\n              _context52.next = 3;\n              return this._accountsResolver.resolve();\n            case 3:\n              return _context52.abrupt(\"return\", this._ixFn.apply(this, _toConsumableArray(this._args).concat([{\n                accounts: this._accounts,\n                signers: this._signers,\n                remainingAccounts: this._remainingAccounts,\n                preInstructions: this._preInstructions,\n                postInstructions: this._postInstructions\n              }])));\n            case 4:\n            case \"end\":\n              return _context52.stop();\n          }\n        }, _callee47, this);\n      }));\n      function instruction() {\n        return _instruction.apply(this, arguments);\n      }\n      return instruction;\n    }()\n    /**\n     * Convenient shortcut to get instructions and pubkeys via\n     * const { pubkeys, instructions } = await prepare();\n     */\n  }, {\n    key: \"prepare\",\n    value: function () {\n      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48() {\n        return _regeneratorRuntime().wrap(function _callee48$(_context53) {\n          while (1) switch (_context53.prev = _context53.next) {\n            case 0:\n              _context53.next = 2;\n              return this.instruction();\n            case 2:\n              _context53.t0 = _context53.sent;\n              _context53.next = 5;\n              return this.pubkeys();\n            case 5:\n              _context53.t1 = _context53.sent;\n              _context53.next = 8;\n              return this._signers;\n            case 8:\n              _context53.t2 = _context53.sent;\n              return _context53.abrupt(\"return\", {\n                instruction: _context53.t0,\n                pubkeys: _context53.t1,\n                signers: _context53.t2\n              });\n            case 10:\n            case \"end\":\n              return _context53.stop();\n          }\n        }, _callee48, this);\n      }));\n      function prepare() {\n        return _prepare.apply(this, arguments);\n      }\n      return prepare;\n    }()\n  }, {\n    key: \"transaction\",\n    value: function () {\n      var _transaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49() {\n        return _regeneratorRuntime().wrap(function _callee49$(_context54) {\n          while (1) switch (_context54.prev = _context54.next) {\n            case 0:\n              if (!this._autoResolveAccounts) {\n                _context54.next = 3;\n                break;\n              }\n              _context54.next = 3;\n              return this._accountsResolver.resolve();\n            case 3:\n              return _context54.abrupt(\"return\", this._txFn.apply(this, _toConsumableArray(this._args).concat([{\n                accounts: this._accounts,\n                signers: this._signers,\n                remainingAccounts: this._remainingAccounts,\n                preInstructions: this._preInstructions,\n                postInstructions: this._postInstructions\n              }])));\n            case 4:\n            case \"end\":\n              return _context54.stop();\n          }\n        }, _callee49, this);\n      }));\n      function transaction() {\n        return _transaction.apply(this, arguments);\n      }\n      return transaction;\n    }()\n  }]);\n  return MethodsBuilder;\n}();\nvar ViewFactory = /*#__PURE__*/function () {\n  function ViewFactory() {\n    _classCallCheck(this, ViewFactory);\n  }\n  _createClass(ViewFactory, null, [{\n    key: \"build\",\n    value: function build(programId, idlIx, simulateFn, idl) {\n      var isMut = idlIx.accounts.find(function (a) {\n        return a.isMut;\n      });\n      var hasReturn = !!idlIx.returns;\n      if (isMut || !hasReturn) return;\n      var view = /*#__PURE__*/function () {\n        var _ref22 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50() {\n          var _a,\n            _b,\n            simulationResult,\n            returnPrefix,\n            returnLog,\n            returnData,\n            returnType,\n            coder,\n            _args56 = arguments;\n          return _regeneratorRuntime().wrap(function _callee50$(_context55) {\n            while (1) switch (_context55.prev = _context55.next) {\n              case 0:\n                _context55.next = 2;\n                return simulateFn.apply(void 0, _args56);\n              case 2:\n                simulationResult = _context55.sent;\n                returnPrefix = \"Program return: \".concat(programId, \" \");\n                returnLog = simulationResult.raw.find(function (l) {\n                  return l.startsWith(returnPrefix);\n                });\n                if (returnLog) {\n                  _context55.next = 7;\n                  break;\n                }\n                throw new Error(\"View expected return log\");\n              case 7:\n                returnData = decode(returnLog.slice(returnPrefix.length));\n                returnType = idlIx.returns;\n                if (returnType) {\n                  _context55.next = 11;\n                  break;\n                }\n                throw new Error(\"View expected return type\");\n              case 11:\n                coder = IdlCoder.fieldLayout({\n                  type: returnType\n                }, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n                return _context55.abrupt(\"return\", coder.decode(returnData));\n              case 13:\n              case \"end\":\n                return _context55.stop();\n            }\n          }, _callee50);\n        }));\n        return function view() {\n          return _ref22.apply(this, arguments);\n        };\n      }();\n      return view;\n    }\n  }]);\n  return ViewFactory;\n}();\nvar NamespaceFactory = /*#__PURE__*/function () {\n  function NamespaceFactory() {\n    _classCallCheck(this, NamespaceFactory);\n  }\n  _createClass(NamespaceFactory, null, [{\n    key: \"build\",\n    /**\n     * Generates all namespaces for a given program.\n     */\n    value: function build(idl, coder, programId, provider, getCustomResolver) {\n      var rpc = {};\n      var instruction = {};\n      var transaction = {};\n      var simulate = {};\n      var methods = {};\n      var view = {};\n      var idlErrors = parseIdlErrors(idl);\n      var account = idl.accounts ? AccountFactory.build(idl, coder, programId, provider) : {};\n      var state = StateFactory.build(idl, coder, programId, provider);\n      idl.instructions.forEach(function (idlIx) {\n        var ixItem = InstructionNamespaceFactory.build(idlIx, function (ixName, ix) {\n          return coder.instruction.encode(ixName, ix);\n        }, programId);\n        var txItem = TransactionFactory.build(idlIx, ixItem);\n        var rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);\n        var simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder, programId, idl);\n        var viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);\n        var methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver && getCustomResolver(idlIx));\n        var name = camelCase(idlIx.name);\n        instruction[name] = ixItem;\n        transaction[name] = txItem;\n        rpc[name] = rpcItem;\n        simulate[name] = simulateItem;\n        methods[name] = methodItem;\n        if (viewItem) {\n          view[name] = viewItem;\n        }\n      });\n      return [rpc, instruction, transaction, account, simulate, methods, state, view];\n    }\n  }]);\n  return NamespaceFactory;\n}();\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/coral-xyz/anchor#examples).\n */\nvar Program = /*#__PURE__*/function () {\n  _createClass(Program, [{\n    key: \"programId\",\n    /**\n     * Address of the program.\n     */\n    get: function get() {\n      return this._programId;\n    }\n    /**\n     * IDL defining the program's interface.\n     */\n  }, {\n    key: \"idl\",\n    get: function get() {\n      return this._idl;\n    }\n    /**\n     * Coder for serializing requests.\n     */\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n    /**\n     * Wallet and network provider.\n     */\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\n     * @param idl       The interface definition.\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context to use. If not provided\n     *                  then uses [[getProvider]].\n     * @param getCustomResolver A function that returns a custom account resolver\n     *                          for the given instruction. This is useful for resolving\n     *                          public keys of missing accounts when building instructions\n     */\n  }]);\n  function Program(idl, programId, provider, coder, getCustomResolver) {\n    _classCallCheck(this, Program);\n    programId = translateAddress(programId);\n    if (!provider) {\n      provider = getProvider();\n    }\n    // Fields.\n    this._idl = idl;\n    this._provider = provider;\n    this._programId = programId;\n    this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(idl);\n    this._events = new EventManager(this._programId, provider, this._coder);\n    // Dynamic namespaces.\n    var _NamespaceFactory$bui = NamespaceFactory.build(idl, this._coder, programId, provider, getCustomResolver !== null && getCustomResolver !== void 0 ? getCustomResolver : function () {\n        return undefined;\n      }),\n      _NamespaceFactory$bui2 = _slicedToArray(_NamespaceFactory$bui, 8),\n      rpc = _NamespaceFactory$bui2[0],\n      instruction = _NamespaceFactory$bui2[1],\n      transaction = _NamespaceFactory$bui2[2],\n      account = _NamespaceFactory$bui2[3],\n      simulate = _NamespaceFactory$bui2[4],\n      methods = _NamespaceFactory$bui2[5],\n      state = _NamespaceFactory$bui2[6],\n      views = _NamespaceFactory$bui2[7];\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.methods = methods;\n    this.state = state;\n    this.views = views;\n  }\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  _createClass(Program, [{\n    key: \"addEventListener\",\n    /**\n     * Invokes the given callback every time the given event is emitted.\n     *\n     * @param eventName The PascalCase name of the event, provided by the IDL.\n     * @param callback  The function to invoke whenever the event is emitted from\n     *                  program logs.\n     */\n    value: function addEventListener(eventName, callback) {\n      return this._events.addEventListener(eventName, callback);\n    }\n    /**\n     * Unsubscribes from the given eventName.\n     */\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee51(listener) {\n        return _regeneratorRuntime().wrap(function _callee51$(_context56) {\n          while (1) switch (_context56.prev = _context56.next) {\n            case 0:\n              _context56.next = 2;\n              return this._events.removeEventListener(listener);\n            case 2:\n              return _context56.abrupt(\"return\", _context56.sent);\n            case 3:\n            case \"end\":\n              return _context56.stop();\n          }\n        }, _callee51, this);\n      }));\n      function removeEventListener(_x82) {\n        return _removeEventListener2.apply(this, arguments);\n      }\n      return removeEventListener;\n    }()\n  }], [{\n    key: \"at\",\n    value: function () {\n      var _at = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(address, provider) {\n        var programId, idl;\n        return _regeneratorRuntime().wrap(function _callee52$(_context57) {\n          while (1) switch (_context57.prev = _context57.next) {\n            case 0:\n              programId = translateAddress(address);\n              _context57.next = 3;\n              return Program.fetchIdl(programId, provider);\n            case 3:\n              idl = _context57.sent;\n              if (idl) {\n                _context57.next = 6;\n                break;\n              }\n              throw new Error(\"IDL not found for program: \".concat(address.toString()));\n            case 6:\n              return _context57.abrupt(\"return\", new Program(idl, programId, provider));\n            case 7:\n            case \"end\":\n              return _context57.stop();\n          }\n        }, _callee52);\n      }));\n      function at(_x83, _x84) {\n        return _at.apply(this, arguments);\n      }\n      return at;\n    }()\n    /**\n     * Fetches an idl from the blockchain.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n  }, {\n    key: \"fetchIdl\",\n    value: function () {\n      var _fetchIdl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53(address, provider) {\n        var programId, idlAddr, accountInfo, idlAccount, inflatedIdl;\n        return _regeneratorRuntime().wrap(function _callee53$(_context58) {\n          while (1) switch (_context58.prev = _context58.next) {\n            case 0:\n              provider = provider !== null && provider !== void 0 ? provider : getProvider();\n              programId = translateAddress(address);\n              _context58.next = 4;\n              return idlAddress(programId);\n            case 4:\n              idlAddr = _context58.sent;\n              _context58.next = 7;\n              return provider.connection.getAccountInfo(idlAddr);\n            case 7:\n              accountInfo = _context58.sent;\n              if (accountInfo) {\n                _context58.next = 10;\n                break;\n              }\n              return _context58.abrupt(\"return\", null);\n            case 10:\n              // Chop off account discriminator.\n              idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n              inflatedIdl = inflate(idlAccount.data);\n              return _context58.abrupt(\"return\", JSON.parse(decode$2(inflatedIdl)));\n            case 13:\n            case \"end\":\n              return _context58.stop();\n          }\n        }, _callee53);\n      }));\n      function fetchIdl(_x85, _x86) {\n        return _fetchIdl.apply(this, arguments);\n      }\n      return fetchIdl;\n    }()\n  }]);\n  return Program;\n}();\nvar SYSTEM_PROGRAM_ID = new PublicKey(\"11111111111111111111111111111111\");\nfunction program(provider) {\n  return new Program(IDL, SYSTEM_PROGRAM_ID, provider, coder());\n}\nfunction coder() {\n  return new SystemCoder(IDL);\n}\nvar IDL = {\n  version: \"0.1.0\",\n  name: \"system_program\",\n  instructions: [{\n    name: \"createAccount\",\n    accounts: [{\n      name: \"from\",\n      isMut: true,\n      isSigner: true\n    }, {\n      name: \"to\",\n      isMut: true,\n      isSigner: true\n    }],\n    args: [{\n      name: \"lamports\",\n      type: \"u64\"\n    }, {\n      name: \"space\",\n      type: \"u64\"\n    }, {\n      name: \"owner\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"assign\",\n    accounts: [{\n      name: \"pubkey\",\n      isMut: true,\n      isSigner: true\n    }],\n    args: [{\n      name: \"owner\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"transfer\",\n    accounts: [{\n      name: \"from\",\n      isMut: true,\n      isSigner: true\n    }, {\n      name: \"to\",\n      isMut: true,\n      isSigner: false\n    }],\n    args: [{\n      name: \"lamports\",\n      type: \"u64\"\n    }]\n  }, {\n    name: \"createAccountWithSeed\",\n    accounts: [{\n      name: \"from\",\n      isMut: true,\n      isSigner: true\n    }, {\n      name: \"to\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"base\",\n      isMut: false,\n      isSigner: true\n    }],\n    args: [{\n      name: \"base\",\n      type: \"publicKey\"\n    }, {\n      name: \"seed\",\n      type: \"string\"\n    }, {\n      name: \"lamports\",\n      type: \"u64\"\n    }, {\n      name: \"space\",\n      type: \"u64\"\n    }, {\n      name: \"owner\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"advanceNonceAccount\",\n    accounts: [{\n      name: \"nonce\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"recentBlockhashes\",\n      isMut: false,\n      isSigner: false\n    }, {\n      name: \"authorized\",\n      isMut: false,\n      isSigner: true\n    }],\n    args: [{\n      name: \"authorized\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"withdrawNonceAccount\",\n    accounts: [{\n      name: \"nonce\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"to\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"recentBlockhashes\",\n      isMut: false,\n      isSigner: false\n    }, {\n      name: \"rent\",\n      isMut: false,\n      isSigner: false\n    }, {\n      name: \"authorized\",\n      isMut: false,\n      isSigner: true\n    }],\n    args: [{\n      name: \"lamports\",\n      type: \"u64\"\n    }]\n  }, {\n    name: \"initializeNonceAccount\",\n    accounts: [{\n      name: \"nonce\",\n      isMut: true,\n      isSigner: true\n    }, {\n      name: \"recentBlockhashes\",\n      isMut: false,\n      isSigner: false\n    }, {\n      name: \"rent\",\n      isMut: false,\n      isSigner: false\n    }],\n    args: [{\n      name: \"authorized\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"authorizeNonceAccount\",\n    accounts: [{\n      name: \"nonce\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"authorized\",\n      isMut: false,\n      isSigner: true\n    }],\n    args: [{\n      name: \"authorized\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"allocate\",\n    accounts: [{\n      name: \"pubkey\",\n      isMut: true,\n      isSigner: true\n    }],\n    args: [{\n      name: \"space\",\n      type: \"u64\"\n    }]\n  }, {\n    name: \"allocateWithSeed\",\n    accounts: [{\n      name: \"account\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"base\",\n      isMut: false,\n      isSigner: true\n    }],\n    args: [{\n      name: \"base\",\n      type: \"publicKey\"\n    }, {\n      name: \"seed\",\n      type: \"string\"\n    }, {\n      name: \"space\",\n      type: \"u64\"\n    }, {\n      name: \"owner\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"assignWithSeed\",\n    accounts: [{\n      name: \"account\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"base\",\n      isMut: false,\n      isSigner: true\n    }],\n    args: [{\n      name: \"base\",\n      type: \"publicKey\"\n    }, {\n      name: \"seed\",\n      type: \"string\"\n    }, {\n      name: \"owner\",\n      type: \"publicKey\"\n    }]\n  }, {\n    name: \"transferWithSeed\",\n    accounts: [{\n      name: \"from\",\n      isMut: true,\n      isSigner: false\n    }, {\n      name: \"base\",\n      isMut: false,\n      isSigner: true\n    }, {\n      name: \"to\",\n      isMut: true,\n      isSigner: false\n    }],\n    args: [{\n      name: \"lamports\",\n      type: \"u64\"\n    }, {\n      name: \"seed\",\n      type: \"string\"\n    }, {\n      name: \"owner\",\n      type: \"publicKey\"\n    }]\n  }],\n  accounts: [{\n    name: \"nonce\",\n    type: {\n      kind: \"struct\",\n      fields: [{\n        name: \"version\",\n        type: \"u32\"\n      }, {\n        name: \"state\",\n        type: \"u32\"\n      }, {\n        name: \"authorizedPubkey\",\n        type: \"publicKey\"\n      }, {\n        name: \"nonce\",\n        type: \"publicKey\"\n      }, {\n        name: \"feeCalculator\",\n        type: {\n          defined: \"FeeCalculator\"\n        }\n      }]\n    }\n  }],\n  types: [{\n    name: \"FeeCalculator\",\n    type: {\n      kind: \"struct\",\n      fields: [{\n        name: \"lamportsPerSignature\",\n        type: \"u64\"\n      }]\n    }\n  }]\n};\nvar Native = /*#__PURE__*/function () {\n  function Native() {\n    _classCallCheck(this, Native);\n  }\n  _createClass(Native, null, [{\n    key: \"system\",\n    value: function system(provider) {\n      return program(provider);\n    }\n  }]);\n  return Native;\n}();\nexport { ACCOUNT_DISCRIMINATOR_SIZE, AccountClient, AnchorError, AnchorProvider, BorshAccountsCoder, BorshCoder, BorshEventCoder, BorshInstructionCoder, BorshStateCoder, EventManager, EventParser, IdlError, LangErrorCode, LangErrorMessage, MethodsBuilderFactory, Native, Program, ProgramError, ProgramErrorStack, StateClient, SystemCoder, eventDiscriminator, getProvider, parseIdlErrors, setProvider, splitArgsAndCtx, stateDiscriminator, toInstruction, translateAddress, translateError, index as utils, validateAccounts };","map":null,"metadata":{},"sourceType":"module"}